// @generated by scripts/extract-demo-apps-to-sandpack-file-object.ts
// npm run extract-demo-apps-to-sandpack-object
/* eslint-disable */

export default {
  'canvas-new': {
    'index.html':
      '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/images/favicon.png" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Cord Sample App - Canvas</title>\n  </head>\n  <body>\n    <div id="root"></div>\n    <script type="module" src="/src/main.tsx"></script>\n  </body>\n</html>\n',
    'package.json':
      '{\n  "name": "cord-sample-canvas",\n  "private": true,\n  "version": "1.0.0",\n  "scripts": {\n    "dev": "vite",\n    "build": "tsc && vite build",\n    "preview": "vite preview"\n  },\n  "dependencies": {\n    "@cord-sdk/react": "^1.10.0",\n    "classnames": "^2.3.1",\n    "konva": "^8.4.3",\n    "react": "^18.0.0",\n    "react-dom": "^18.0.0",\n    "react-konva": "^18.2.10"\n  },\n  "devDependencies": {\n    "@cord-sdk/types": "^1.10.0",\n    "@types/react": "^18.2.18",\n    "@types/react-dom": "^18.0.0",\n    "@vitejs/plugin-react": "^1.3.0",\n    "typescript": "~5.1.6",\n    "vite": "^2.9.9"\n  }\n}\n',
    'public/images/Pin.svg':
      '<svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">\n<path d="M1.94118 17.5H9C13.6944 17.5 17.5 13.6944 17.5 9C17.5 4.30558 13.6944 0.5 9 0.5C4.30558 0.5 0.5 4.30558 0.5 9V16.0588C0.5 16.8548 1.14524 17.5 1.94118 17.5Z" fill="#2E2E2E"/>\n<path d="M1.94118 17.5H9C13.6944 17.5 17.5 13.6944 17.5 9C17.5 4.30558 13.6944 0.5 9 0.5C4.30558 0.5 0.5 4.30558 0.5 9V16.0588C0.5 16.8548 1.14524 17.5 1.94118 17.5Z" stroke="#2E2E2E"/>\n</svg>\n',
    'src/App.tsx':
      "import { CordProvider } from '@cord-sdk/react';\n\n\nimport { CanvasAndCommentsProvider } from './CanvasAndCommentsContext';\nimport { EXAMPLE_CORD_LOCATION } from './canvasUtils';\nimport Canvas from './components/Canvas';\nimport { useCordSampleToken_DEMO_ONLY_NOT_FOR_PRODUCTION } from './utils';\n\nexport default function App() {\n  // This must be replaced with your code that obtains the client auth token\n  // from your own backend, signed with your own API secret.\n  const clientAuthToken = useCordSampleToken_DEMO_ONLY_NOT_FOR_PRODUCTION();\n\n  return (\n    // All the Cord React components must be children of a single CordProvider component.\n    <CordProvider clientAuthToken={clientAuthToken}>\n      \n      {clientAuthToken && (\n        <CanvasAndCommentsProvider location={EXAMPLE_CORD_LOCATION}>\n          <Canvas />\n        </CanvasAndCommentsProvider>\n      )}\n    </CordProvider>\n  );\n}\n",
    'src/CanvasAndCommentsContext.tsx':
      "import type { PropsWithChildren, RefObject } from 'react';\nimport type { Stage } from 'konva/lib/Stage';\nimport {\n  createContext,\n  useCallback,\n  useState,\n  useMemo,\n  useRef,\n  useEffect,\n} from 'react';\nimport { thread } from '@cord-sdk/react';\nimport type { Location } from '@cord-sdk/types';\nimport type { OpenThread, Pin } from './canvasUtils';\nimport { updatePinPositionOnStage, getPinFromThread } from './canvasUtils';\n\n// Context for storing all thread related information\ntype CanvasAndCommentsContextType = {\n  // Map of all threads on current page, mapping from thread's ID to its\n  // calculated pins\n  threads: ReadonlyMap<string, Pin>;\n  // Adds a thread to the threads map\n  addThread: (threadId: string, metadata: Pin) => void;\n  // Removes a thread from the threads map\n  removeThreadIfEmpty: (openThread: OpenThread) => void;\n\n  // The id of the thread open on this page, and if it's empty (or null if none is open)\n  openThread: OpenThread;\n  setOpenThread: (arg: OpenThread) => void;\n\n  // True if user can leave threads at the moment\n  inThreadCreationMode: boolean;\n  setInThreadCreationMode: React.Dispatch<React.SetStateAction<boolean>>;\n\n  // The stage (canvas), and container of the canvas\n  canvasStageRef: RefObject<Stage>;\n  canvasContainerRef: RefObject<HTMLDivElement>;\n\n  // Panning on Canvas\n  isPanningCanvas: boolean;\n  setIsPanningCanvas: React.Dispatch<React.SetStateAction<boolean>>;\n\n  // Updates all the thread co-ordinates relative to the canvas\n  recomputePinPositions: () => void;\n\n  // The container of the list of comments on the right has side of canvas\n  commentsListContainerRef: RefObject<HTMLDivElement>;\n};\nexport const CanvasAndCommentsContext = createContext<\n  CanvasAndCommentsContextType | undefined\n>(undefined);\n\nexport function CanvasAndCommentsProvider({\n  children,\n  location,\n}: PropsWithChildren<{ location: Location }>) {\n  const canvasContainerRef = useRef<HTMLDivElement>(null);\n  const canvasStageRef = useRef<Stage>(null);\n\n  const commentsListContainerRef = useRef<HTMLDivElement>(null);\n\n  const [threads, setThreads] = useState<Map<string, Pin>>(new Map());\n\n  const addThread = useCallback((threadId: string, metadata: Pin) => {\n    setThreads((oldThreads) => {\n      const newThreads = new Map(oldThreads);\n      newThreads.set(threadId, metadata);\n      return newThreads;\n    });\n  }, []);\n\n  const removeThreadIfEmpty = useCallback((removeThread: OpenThread) => {\n    if (!removeThread || !removeThread.empty) {\n      return;\n    }\n\n    setThreads((oldThreads) => {\n      if (!oldThreads.has(removeThread.threadID)) {\n        return oldThreads;\n      }\n      const newThreads = new Map(oldThreads);\n      newThreads.delete(removeThread.threadID);\n      return newThreads;\n    });\n  }, []);\n\n  const [openThread, setOpenThread] = useState<OpenThread>(null);\n\n  const [inThreadCreationMode, setInThreadCreationMode] =\n    useState<boolean>(false);\n\n  const [isPanningCanvas, setIsPanningCanvas] = useState<boolean>(false);\n\n  const recomputePinPositions = useCallback(() => {\n    if (!canvasStageRef.current) {\n      return;\n    }\n    const stage = canvasStageRef.current;\n    setThreads((oldThreads) => {\n      const updatedThreads = new Map<string, Pin>();\n      Array.from(oldThreads).forEach(([id, oldThread]) => {\n        const updatedPin = updatePinPositionOnStage(stage, oldThread);\n        if (updatedPin) {\n          updatedThreads.set(id, updatedPin);\n        }\n      });\n\n      return updatedThreads;\n    });\n  }, []);\n  // Fetch existing threads associated with location\n  const {\n    threads: threadSummaries,\n    hasMore,\n    loading,\n    fetchMore,\n  } = thread.useLocationData(location, { includeResolved: false });\n  useEffect(() => {\n    if (loading) {\n      return;\n    }\n    if (hasMore) {\n      // NOTE: For this demo, fetch all threads on the page.\n      void fetchMore(1000);\n    }\n\n    if (!canvasStageRef.current) {\n      return;\n    }\n    const stage = canvasStageRef.current;\n    threadSummaries\n      .filter(\n        (t) => !t.resolved && (t.total > 0 || openThread?.threadID === t.id),\n      )\n      .forEach((t) => {\n        const pinData = getPinFromThread(stage, t);\n        if (pinData) {\n          addThread(t.id, pinData);\n        }\n      });\n  }, [\n    addThread,\n    fetchMore,\n    hasMore,\n    loading,\n    openThread?.threadID,\n    threadSummaries,\n  ]);\n\n  const context = useMemo(\n    () => ({\n      threads,\n      addThread,\n      removeThreadIfEmpty,\n      openThread,\n      setOpenThread,\n      inThreadCreationMode,\n      setInThreadCreationMode,\n      canvasStageRef,\n      canvasContainerRef,\n      isPanningCanvas,\n      setIsPanningCanvas,\n      recomputePinPositions,\n      commentsListContainerRef,\n    }),\n    [\n      addThread,\n      inThreadCreationMode,\n      isPanningCanvas,\n      openThread,\n      removeThreadIfEmpty,\n      threads,\n      recomputePinPositions,\n    ],\n  );\n  return (\n    <CanvasAndCommentsContext.Provider value={context}>\n      {children}\n    </CanvasAndCommentsContext.Provider>\n  );\n}\n",
    'src/canvasUtils.ts':
      "import { v4 as uuid } from 'uuid';\nimport type { Stage } from 'konva/lib/Stage';\nimport type { ThreadSummary } from '@cord-sdk/types';\n\nexport const EXAMPLE_CORD_LOCATION = {\n  page: 'canvas',\n};\n\nexport type ThreadMetadata = {\n  elementName: string;\n  relativeX: number;\n  relativeY: number;\n};\n\nexport type CanvasThreadData = Pick<ThreadSummary, 'firstMessage' | 'total'> & {\n  metadata: ThreadMetadata;\n};\n\n/**\n * x and y help us position the pins on the viewport (so when we pan, zoom, drag\n * shapes etc) where as relativeX and relativeY are purely to know the exact size\n * (at 1:1 scale) of the distance between pin position on the element.\n * That way we can calculate x, y.\n */\nexport type Pin = {\n  threadID: string;\n  thread: CanvasThreadData;\n  x: number;\n  y: number;\n};\n\nexport type OpenThread = {\n  threadID: string;\n  empty: boolean;\n} | null;\n\nexport function getStageData(stage: Stage) {\n  const { x, y } = stage.getPosition();\n  const scale = stage.scaleX();\n  const stagePointerPosition = stage.getPointerPosition() ?? { x: 0, y: 0 };\n  return { stageX: x, stageY: y, scale, stagePointerPosition };\n}\n\nexport function createNewPin({\n  threadMetadata,\n  x,\n  y,\n}: {\n  threadMetadata: ThreadMetadata;\n  x: number;\n  y: number;\n}): Pin {\n  return {\n    threadID: uuid(),\n    thread: {\n      metadata: threadMetadata,\n      firstMessage: null,\n      total: 0,\n    },\n    x: roundNumber(x),\n    y: roundNumber(y),\n  };\n}\n\nfunction roundNumber(number: number) {\n  return Number(number.toPrecision(4));\n}\n\nexport function getPinFromThread(\n  stage: Stage,\n  thread: ThreadSummary,\n): Pin | null {\n  const metadata = extractDataFromThreadMetadata(thread.metadata);\n  if (!metadata) {\n    return null;\n  }\n  return computePinPosition(stage, thread.id, { ...thread, metadata }, true);\n}\n\nfunction extractDataFromThreadMetadata(\n  metadata: ThreadSummary['metadata'],\n): ThreadMetadata | null {\n  if (\n    !('elementName' in metadata) ||\n    typeof metadata['elementName'] !== 'string'\n  ) {\n    return null;\n  }\n\n  if (!('relativeX' in metadata) || typeof metadata['relativeX'] !== 'number') {\n    return null;\n  }\n\n  if (!('relativeY' in metadata) || typeof metadata['relativeY'] !== 'number') {\n    return null;\n  }\n\n  return {\n    elementName: metadata.elementName,\n    relativeX: metadata.relativeX,\n    relativeY: metadata.relativeY,\n  };\n}\n\nexport function computePinPosition(\n  stage: Stage,\n  threadID: string,\n  thread: CanvasThreadData,\n  // Including the stage means we are calculating where the new pin position\n  // should be otherwise we are getting the position of the existing pin\n  includeStageCoords: boolean,\n): Pin | null {\n  const { elementName, relativeX, relativeY } = thread.metadata;\n\n  const { stageX, stageY, scale } = getStageData(stage);\n\n  let pinX, pinY: number;\n\n  if (elementName === 'stage') {\n    pinX = relativeX * scale;\n    pinY = relativeY * scale;\n  } else {\n    const node = stage.findOne(`.${elementName}`);\n    if (!node) {\n      return null;\n    }\n\n    const elementPosition = node.getPosition();\n\n    pinX = (elementPosition.x + relativeX) * scale;\n    pinY = (elementPosition.y + relativeY) * scale;\n  }\n\n  if (includeStageCoords) {\n    pinX = pinX + stageX;\n    pinY = pinY + stageY;\n  }\n  return {\n    threadID,\n    thread,\n    x: pinX,\n    y: pinY,\n  };\n}\n\nexport function updatePinPositionOnStage(stage: Stage, pin: Pin) {\n  return computePinPosition(stage, pin.threadID, pin.thread, true);\n}\n\nexport function getPinPositionOnStage(stage: Stage, pin: Pin) {\n  return computePinPosition(stage, pin.threadID, pin.thread, false);\n}\n\n// TODO - tweak to avoid header\nexport function isPinInView(stage: Stage, pin: Pin) {\n  const pinElement = document.getElementById(pin.threadID);\n\n  if (!pinElement) {\n    throw new Error('Pin does not exist');\n  }\n\n  // Gets position relative to the viewport\n  const pinRects = pinElement?.getBoundingClientRect();\n\n  if (!pinRects) {\n    return false;\n  }\n  // Buffer of 50px around the left and right edges, and remove additional 300\n  // for the comments list\n  if (pinRects.x < 50 || pinRects.x > stage.width() - 300 + 50) {\n    return false;\n  }\n\n  // Buffer of 100px on the top and bottom\n  if (pinRects.y < 100 || pinRects.y > stage.height() - 100) {\n    return false;\n  }\n\n  return true;\n}\n",
    'src/components/Canvas.tsx':
      "import { Stage, Layer, Rect, Circle, RegularPolygon } from 'react-konva';\nimport type { KonvaEventObject } from 'konva/lib/Node';\nimport cx from 'classnames';\nimport { useCallback, useContext, useEffect, useRef } from 'react';\nimport { Pin, Thread } from '@cord-sdk/react';\nimport type { ThreadMetadata } from '../canvasUtils';\nimport {\n  createNewPin,\n  getStageData,\n  EXAMPLE_CORD_LOCATION,\n} from '../canvasUtils';\nimport { CanvasAndCommentsContext } from '../CanvasAndCommentsContext';\nimport { CanvasCommentsList } from './CanvasCommentsList';\n\nexport default function Canvas() {\n  const {\n    threads,\n    canvasStageRef,\n    canvasContainerRef,\n    openThread,\n    setOpenThread,\n    inThreadCreationMode,\n    setInThreadCreationMode,\n    removeThreadIfEmpty,\n    addThread,\n    isPanningCanvas,\n    setIsPanningCanvas,\n    recomputePinPositions,\n  } = useContext(CanvasAndCommentsContext)!;\n\n  const timeoutPanningRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  const updateCanvasSize = useCallback(() => {\n    const stage = canvasStageRef.current;\n    if (!canvasContainerRef.current || !stage) {\n      return;\n    }\n    stage.size({\n      width: canvasContainerRef.current.clientWidth,\n      height: canvasContainerRef.current.clientHeight,\n    });\n  }, [canvasContainerRef, canvasStageRef]);\n\n  useEffect(() => {\n    // Sets the canvas stage initially\n    updateCanvasSize();\n  }, [updateCanvasSize]);\n\n  useEffect(() => {\n    // When window resizes, resize canvas\n    window.addEventListener('resize', updateCanvasSize);\n    return () => {\n      window.removeEventListener('resize', updateCanvasSize);\n    };\n  }, [updateCanvasSize]);\n\n  useEffect(() => {\n    const preventBrowserNavigation = (e: WheelEvent) => {\n      if (e.target instanceof HTMLCanvasElement) {\n        e.preventDefault();\n      }\n    };\n    window.addEventListener('wheel', preventBrowserNavigation, {\n      passive: false,\n    });\n    return window.removeEventListener('wheel', preventBrowserNavigation);\n  }, []);\n\n  const onStageClick = useCallback(\n    (e: KonvaEventObject<MouseEvent>) => {\n      removeThreadIfEmpty(openThread);\n      setOpenThread(null);\n      if (!inThreadCreationMode) {\n        return;\n      }\n      e.evt.preventDefault();\n      e.evt.stopPropagation();\n\n      if (!canvasStageRef.current) {\n        return;\n      }\n      const { x: relativeX, y: relativeY } =\n        e.target.getRelativePointerPosition();\n\n      const elementPosition = e.target.getPosition();\n\n      const { stageX, stageY, scale, stagePointerPosition } = getStageData(\n        canvasStageRef.current,\n      );\n\n      const elementName = e.target.attrs.name;\n\n      if (\n        elementName !== 'circle' &&\n        elementName !== 'square' &&\n        elementName !== 'diamond' &&\n        elementName !== 'stage'\n      ) {\n        return;\n      }\n\n      e.target.stopDrag();\n\n      let x, y: number;\n      if (elementName === 'stage') {\n        x = stagePointerPosition.x;\n        y = stagePointerPosition.y;\n      } else {\n        x = stageX + (elementPosition.x + relativeX) * scale;\n        y = stageY + (elementPosition.y + relativeY) * scale;\n      }\n\n      const threadMetadata: ThreadMetadata = {\n        relativeX,\n        relativeY,\n        elementName,\n      };\n\n      const pin = createNewPin({\n        threadMetadata,\n        x,\n        y,\n      });\n\n      addThread(pin.threadID, pin);\n\n      setOpenThread({ threadID: pin.threadID, empty: true });\n      setInThreadCreationMode(false);\n    },\n    [\n      addThread,\n      canvasStageRef,\n      inThreadCreationMode,\n      openThread,\n      removeThreadIfEmpty,\n      setInThreadCreationMode,\n      setOpenThread,\n    ],\n  );\n\n  const onEscapePress = useCallback(\n    (event: KeyboardEvent) => {\n      if (event.key === 'Escape') {\n        setInThreadCreationMode(false);\n        removeThreadIfEmpty(openThread);\n        setOpenThread(null);\n      }\n    },\n    [openThread, removeThreadIfEmpty, setInThreadCreationMode, setOpenThread],\n  );\n\n  useEffect(() => {\n    window.addEventListener('keydown', onEscapePress);\n    return () => window.removeEventListener('keydown', onEscapePress);\n  }, [onEscapePress]);\n\n  const onStageWheel = useCallback(\n    ({ evt }: KonvaEventObject<WheelEvent>) => {\n      evt.preventDefault();\n      setIsPanningCanvas(true);\n      // Improving the panning experience over canvas\n      if (timeoutPanningRef.current !== null) {\n        clearTimeout(timeoutPanningRef.current);\n      }\n      timeoutPanningRef.current = setTimeout(\n        () => setIsPanningCanvas(false),\n        300,\n      );\n\n      const isPinchToZoom = evt.ctrlKey;\n      const stage = canvasStageRef.current;\n      if (!stage) {\n        return;\n      }\n      if (isPinchToZoom) {\n        // https://konvajs.org/docs/sandbox/Zooming_Relative_To_Pointer.html\n        const scaleBy = 1.03;\n        let direction = evt.deltaY > 0 ? 1 : -1;\n        // When we zoom on trackpads,\n        // e.evt.ctrlKey is true so in that case lets revert direction.\n        if (evt.ctrlKey) {\n          direction = -direction;\n        }\n        const oldScale = stage.scaleX();\n        const newScale =\n          direction > 0 ? oldScale * scaleBy : oldScale / scaleBy;\n        const pointer = stage.getPointerPosition() ?? { x: 0, y: 0 };\n        const mousePointTo = {\n          x: (pointer.x - stage.x()) / oldScale,\n          y: (pointer.y - stage.y()) / oldScale,\n        };\n\n        stage.scale({ x: newScale, y: newScale });\n        stage.position({\n          x: pointer.x - mousePointTo.x * newScale,\n          y: pointer.y - mousePointTo.y * newScale,\n        });\n      } else {\n        // Just panning the canvas\n        const { deltaX, deltaY } = evt;\n        const { x, y } = stage.getPosition();\n        stage.position({ x: x - deltaX, y: y - deltaY });\n      }\n      recomputePinPositions();\n    },\n    [canvasStageRef, setIsPanningCanvas, recomputePinPositions],\n  );\n\n  const onElementDrag = useCallback(\n    (_e: KonvaEventObject<DragEvent>) => {\n      const stage = canvasStageRef.current;\n      if (!stage) {\n        return;\n      }\n\n      recomputePinPositions();\n      removeThreadIfEmpty(openThread);\n      setOpenThread(null);\n    },\n    [\n      canvasStageRef,\n      openThread,\n      recomputePinPositions,\n      removeThreadIfEmpty,\n      setOpenThread,\n    ],\n  );\n\n  return (\n    <div className=\"canvasAndCordContainer\" ref={canvasContainerRef}>\n      <Stage\n        id=\"stage\"\n        ref={canvasStageRef}\n        className={cx('canvasContainer', {\n          commentingModeCursor: inThreadCreationMode,\n        })}\n        name=\"stage\"\n        onClick={onStageClick}\n        onWheel={onStageWheel}\n      >\n        <Layer>\n          <Circle\n            radius={60}\n            fill=\"#0ACF83\"\n            x={380}\n            y={410}\n            name=\"circle\"\n            draggable={!inThreadCreationMode}\n            onDragMove={onElementDrag}\n          />\n          <Rect\n            fill={'#1ABCFE'}\n            width={120}\n            height={120}\n            x={180}\n            y={200}\n            name=\"square\"\n            draggable={!inThreadCreationMode}\n            onDragMove={onElementDrag}\n          />\n          <RegularPolygon\n            sides={4}\n            fill={'#FF7262'}\n            radius={85}\n            x={480}\n            y={100}\n            name=\"diamond\"\n            draggable={!inThreadCreationMode}\n            onDragMove={onElementDrag}\n          />\n        </Layer>\n      </Stage>\n      <div className=\"canvasButtonGroup\">\n        <button\n          type=\"button\"\n          onClick={() => {\n            setInThreadCreationMode((prev) => !prev);\n            removeThreadIfEmpty(openThread);\n          }}\n        >\n          <img src={'/images/Pin.png'} alt=\"Chat bubble\" />\n          <span>{inThreadCreationMode ? 'Cancel' : 'Add Comment'}</span>\n        </button>\n      </div>\n      {Array.from(threads).map(([id, pin]) => (\n        <Pin\n          key={id}\n          id={id}\n          location={EXAMPLE_CORD_LOCATION}\n          threadId={pin.threadID}\n          style={{\n            left: pin.x,\n            top: pin.y,\n            zIndex: openThread?.threadID === pin.threadID ? 1 : 0,\n            pointerEvents: isPanningCanvas ? 'none' : 'auto',\n          }}\n          onClick={() => {\n            if (openThread?.threadID === pin.threadID && !openThread.empty) {\n              setOpenThread(null);\n              return;\n            }\n            if (openThread?.threadID !== pin.threadID) {\n              setOpenThread({ threadID: pin.threadID, empty: false });\n              removeThreadIfEmpty(openThread);\n              return;\n            }\n          }}\n        >\n          <Thread\n            location={EXAMPLE_CORD_LOCATION}\n            threadId={pin.threadID}\n            metadata={pin.thread.metadata}\n            style={{\n              visibility:\n                openThread?.threadID === pin.threadID ? 'visible' : 'hidden',\n            }}\n            showHeader={false}\n            showPlaceholder={false}\n            onThreadInfoChange={(threadInfo) => {\n              if (\n                threadInfo.messageCount > 0 &&\n                openThread?.threadID === pin.threadID\n              ) {\n                setOpenThread({ threadID: pin.threadID, empty: false });\n              }\n            }}\n          />\n        </Pin>\n      ))}\n      <CanvasCommentsList />\n    </div>\n  );\n}\n",
    'src/components/CanvasCommentsList.tsx':
      "import { useCallback, useContext, useMemo } from 'react';\nimport { Message } from '@cord-sdk/react';\nimport cx from 'classnames';\nimport { CanvasAndCommentsContext } from '../CanvasAndCommentsContext';\nimport { getPinPositionOnStage, isPinInView } from '../canvasUtils';\n\nexport function CanvasCommentsList() {\n  const {\n    threads,\n    openThread,\n    canvasStageRef,\n    setOpenThread,\n    recomputePinPositions,\n    commentsListContainerRef,\n  } = useContext(CanvasAndCommentsContext)!;\n\n  const navigateToPin = useCallback(\n    (threadID: string) => {\n      const foundPin = threads.get(threadID);\n\n      if (!foundPin) {\n        console.warn('Could not find pin on the page');\n        return;\n      }\n\n      if (!canvasStageRef.current || !commentsListContainerRef.current) {\n        return;\n      }\n\n      const stage = canvasStageRef.current;\n\n      // check if pin is already in view - if so then we open the thread\n      if (isPinInView(stage, foundPin)) {\n        setOpenThread({ threadID: foundPin.threadID, empty: false });\n        return;\n      }\n\n      // Pin is not in view so we have to move the stage and pin to show it\n      const stageHeight = stage.height();\n      const stageWidth = stage.width();\n\n      // Get Shape Position or Stage Position\n      const pinPositionOnStage = getPinPositionOnStage(stage, foundPin);\n\n      if (!pinPositionOnStage) {\n        return;\n      }\n\n      const stageCenter = {\n        x: (stageWidth - commentsListContainerRef.current.clientWidth) / 2, // Ignore the comments list as well\n        y: stageHeight / 2,\n      };\n\n      stage.position({\n        x: stageCenter.x - pinPositionOnStage.x,\n        y: stageCenter.y - pinPositionOnStage.y,\n      });\n      recomputePinPositions();\n      setOpenThread({ threadID: foundPin.threadID, empty: false });\n    },\n    [\n      threads,\n      canvasStageRef,\n      commentsListContainerRef,\n      recomputePinPositions,\n      setOpenThread,\n    ],\n  );\n\n  const threadsInfo = useMemo(() => {\n    return Array.from(threads);\n  }, [threads]);\n\n  return (\n    <div className=\"commentsListContainer\" ref={commentsListContainerRef}>\n      {threadsInfo.length === 0 ? (\n        <p className=\"empty\">No comments</p>\n      ) : (\n        threadsInfo.map(([id, cordThread]) => {\n          if (cordThread?.thread.firstMessage) {\n            const { total, firstMessage } = cordThread.thread;\n            return (\n              <div\n                className={cx('messageContainer', {\n                  openThread: openThread?.threadID === id,\n                })}\n                key={id}\n                onClick={() => navigateToPin(id)}\n              >\n                <Message threadId={id} messageId={firstMessage?.id} />\n                {total > 1 && (\n                  <div className=\"commentReplies\">\n                    {total - 1 === 1 ? '1 reply' : `${total - 1} replies`}\n                  </div>\n                )}\n                <hr />\n              </div>\n            );\n          } else {\n            return null;\n          }\n        })\n      )}\n    </div>\n  );\n}\n",
    'src/css/index.css':
      "*,\n*::before,\n*::after {\n  box-sizing: border-box;\n}\n\n* {\n  margin: 0;\n}\n\nbody {\n  background: #f0f0f0;\n  margin: 0;\n  padding: 0;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n    sans-serif;\n}\n\n:root {\n  --comments-list-width: 300px;\n  --header-height: 64px;\n}\n\n.canvasAndCordContainer {\n  background: #f6f6f6;\n  height: 100vh;\n  position: relative;\n  /* Prevents scroll bars from appearing for the canvas */\n  overflow: hidden;\n}\n\n.canvasButtonGroup {\n  position: absolute;\n  bottom: 40px;\n  left: 40px;\n  display: flex;\n  align-items: center;\n  gap: 16px;\n  /* The buttons will appear above the canvas and pins */\n  z-index: 2;\n}\n\n.canvasButtonGroup button {\n  align-items: center;\n  background: #fff;\n  border-radius: 64px;\n  border: 1px solid #dadce0;\n  box-shadow: 0px 2px 4px 0px rgba(0, 0, 0, 0.08);\n  cursor: pointer;\n  display: flex;\n  gap: 8px;\n  padding: 10px 16px;\n}\n\n.canvasButtonGroup button img {\n  width: 16px;\n  height: 16px;\n}\n\n.canvasButtonGroup button:active {\n  box-shadow: 0 0 0 #ffffff;\n}\n\n.commentingModeCursor {\n  cursor: url('/images/Pin.svg') 0 32, pointer;\n}\n\n/* Cord Component - TODO move to own file */\ncord-pin.cord-component {\n  position: absolute;\n  /* Adjust translate if pin size changes */\n  transform: translate(0px, -34px);\n}\n\ncord-thread.cord-component {\n  position: absolute;\n  left: 40px;\n}\n\n/* Comments List */\n\n.commentsListContainer {\n  position: absolute;\n  right: 0;\n  top: var(--header-height);\n  bottom: 0;\n  background: #ffffff;\n  overflow-y: auto;\n  overflow-x: hidden;\n  width: var(--comments-list-width);\n  /* Shown above the canvas */\n  z-index: 2;\n}\n\n.commentsListContainer .empty {\n  text-align: center;\n}\n\n.commentsListContainer .cord-message {\n  grid-template-columns: repeat(2, auto) 2fr 16px;\n  grid-template-rows: 24px repeat(3, auto);\n  grid-template-areas:\n    'avatar . . . optionsMenu '\n    'authorName timestamp . . .'\n    'messageContent messageContent messageContent messageContent .'\n    'reactions reactions reactions reactions .';\n  gap: 8px;\n  border-radius: 0;\n  background-color: transparent;\n  padding-bottom: 8px;\n}\n\n/* The messages in the comments list */\n\n.commentsListContainer\n  .cord-message\n  :is(.cord-reactions-container, [data-cord-button='select-emoji']) {\n  display: none;\n}\n\n.commentsListContainer\n  .cord-message\n  .cord-message-options-buttons\n  [data-cord-button='thread-options'] {\n  background: rgba(0, 0, 0, 0.06);\n}\n\n.commentsListContainer .commentReplies {\n  padding: 8px 8px 16px 8px;\n  color: #696a6c;\n  font-size: 12px;\n  font-style: normal;\n  font-weight: 400;\n  line-height: 16px;\n}\n\n.commentsListContainer .messageContainer {\n  padding: 8px 12px 0 12px;\n  position: relative;\n}\n\n.commentsListContainer hr {\n  border: none;\n  border-bottom: 1px solid #dadce0;\n  margin: 0 4px;\n}\n\n.commentsListContainer .messageContainer:hover {\n  background: rgba(0, 0, 0, 0.06);\n}\n\n.commentsListContainer .messageContainer.openThread {\n  background-color: rgb(84, 141, 84, 0.06);\n}\n",
    'src/main.tsx':
      "import * as ReactDOM from 'react-dom/client';\nimport App from './App';\nimport './css/index.css';\n\nReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(\n  <App />,\n);\n",
    'src/utils.ts':
      "import { useEffect, useState } from 'react';\n\nconst CORD_TOKEN_LOCALSTORAGE_KEY = 'cord_token';\nconst CORD_SAMPLE_TOKEN_ENDPOINT = 'https://api.cord.com/sample-token';\n\nconst ONE_MINUTE_MS = 60 * 1000;\nconst ONE_DAY_MS = ONE_MINUTE_MS * 60 * 24;\nconst SEVEN_DAYS_MS = ONE_DAY_MS * 7;\n\nfunction canUseLocalStorage() {\n  try {\n    typeof window.localStorage;\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function useCordSampleToken_DEMO_ONLY_NOT_FOR_PRODUCTION() {\n  const [{ value: cordAuthToken, hasExpired }, setCordAuthToken] = useState<{\n    value: string | null;\n    hasExpired: boolean;\n  }>(\n    canUseLocalStorage()\n      ? () => getLocalStorageItemWithExpiry(CORD_TOKEN_LOCALSTORAGE_KEY)\n      : { value: null, hasExpired: true },\n  );\n\n  useEffect(() => {\n    if (!cordAuthToken || hasExpired) {\n      void fetchCordSampleToken().then((token) => {\n        if (token) {\n          setCordAuthToken({ value: token, hasExpired: false });\n\n          if (canUseLocalStorage()) {\n            localStorage.setItem(\n              CORD_TOKEN_LOCALSTORAGE_KEY,\n              withExpiry(\n                token,\n                // Sample token expires after 7 days\n                getTimeInXMillisecondsFromNow(SEVEN_DAYS_MS),\n              ),\n            );\n          } else {\n            console.warn(\n              `Cannot save Cord token in the localStorage. If you refresh the page, you will lose all your messages.`,\n            );\n          }\n        }\n      });\n    }\n  }, [cordAuthToken, hasExpired]);\n\n  return cordAuthToken;\n}\n\nasync function fetchCordSampleToken(): Promise<string | null> {\n  try {\n    const response = await fetch(CORD_SAMPLE_TOKEN_ENDPOINT, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ extended: 'true' }),\n    });\n\n    if (response.status !== 200) {\n      throw new Error('Failed to fetch Cord sample token');\n    }\n\n    const { client_auth_token } = await response.json();\n    return client_auth_token;\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction getLocalStorageItemWithExpiry(key: string) {\n  const itemStr = localStorage.getItem(key);\n  if (!itemStr) {\n    return { value: null, hasExpired: true };\n  }\n\n  try {\n    const item = JSON.parse(itemStr);\n    const isValid = Boolean(item.expiry && item.value);\n    if (!isValid) {\n      localStorage.removeItem(key);\n      return { value: null, hasExpired: true };\n    }\n\n    const hasExpired = new Date().getTime() > item.expiry;\n    return { value: item.value, hasExpired };\n  } catch {\n    localStorage.removeItem(key);\n    return { value: null, hasExpired: true };\n  }\n}\n\nexport function withExpiry(value: string, expiry: number) {\n  const item = {\n    value: value,\n    expiry,\n  };\n\n  return JSON.stringify(item);\n}\n\nfunction getTimeInXMillisecondsFromNow(xMilliseconds: number) {\n  return new Date(new Date().getTime() + xMilliseconds).getTime();\n}\n",
    'tsconfig.json':
      '{\n  "compilerOptions": {\n    "target": "ESNext",\n    "useDefineForClassFields": true,\n    "lib": ["DOM", "DOM.Iterable", "ESNext"],\n    "allowJs": false,\n    "skipLibCheck": true,\n    "esModuleInterop": false,\n    "allowSyntheticDefaultImports": true,\n    "strict": true,\n    "forceConsistentCasingInFileNames": true,\n    "module": "ESNext",\n    "moduleResolution": "Node",\n    "resolveJsonModule": true,\n    "isolatedModules": true,\n    "noEmit": true,\n    "jsx": "react-jsx"\n  },\n  "include": ["src"],\n  "references": [{ "path": "./tsconfig.node.json" }]\n}\n',
  },
  document: {
    'index.html':
      '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/src/images/favicon.png" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Cord Sample App - Document</title>\n  </head>\n  <body>\n    <div id="root"></div>\n    <script type="module" src="/src/main.tsx"></script>\n  </body>\n</html>\n',
    'package.json':
      '{\n  "name": "cord-sample-document",\n  "private": true,\n  "version": "1.0.0",\n  "type": "module",\n  "scripts": {\n    "dev": "vite",\n    "build": "tsc && vite build",\n    "preview": "vite preview"\n  },\n  "dependencies": {\n    "@cord-sdk/react": "^1.15.1",\n    "react": "^18.2.0",\n    "react-dom": "^18.2.0",\n    "react-syntax-highlighter": "^15.5.0"\n  },\n  "devDependencies": {\n    "@cord-sdk/types": "^1.15.1",\n    "@types/react": "^18.2.18",\n    "@types/react-dom": "^18.0.6",\n    "@types/react-syntax-highlighter": "^15.5.5",\n    "@vitejs/plugin-react": "^2.0.1",\n    "typescript": "~5.1.6",\n    "vite": "^3.0.7"\n  }\n}\n',
    'src/App.tsx':
      "import { CordProvider } from '@cord-sdk/react';\n\n\nimport { useCordSampleToken_DEMO_ONLY_NOT_FOR_PRODUCTION } from './utils';\nimport { Document } from './components/Document';\nimport { ThreadsProvider } from './ThreadsContext';\n\nexport default function App() {\n  const authToken = useCordSampleToken_DEMO_ONLY_NOT_FOR_PRODUCTION();\n  return (\n    // All the Cord React components must be children of a single CordProvider component.\n    <CordProvider clientAuthToken={authToken}>\n      \n      {authToken && (\n        <ThreadsProvider>\n          <Document />\n        </ThreadsProvider>\n      )}\n    </CordProvider>\n  );\n}\n",
    'src/ThreadsContext.tsx':
      "import { thread } from '@cord-sdk/react';\nimport type { PropsWithChildren } from 'react';\nimport {\n  useCallback,\n  useEffect,\n  useState,\n  createContext,\n  useMemo,\n} from 'react';\nimport { LOCATION } from './components/Document';\n\nexport type ThreadMetadata = {\n  startNodeId: string;\n  startOffset: number;\n  endNodeId: string;\n  endOffset: number;\n};\n\n// Context for storing all thread related information\ntype ThreadsContextType = {\n  // Map of all threads on current page, mapping from thread's ID to its\n  // metadata\n  threads: ReadonlyMap<\n    string,\n    { metadata: ThreadMetadata; totalMessages: number }\n  >;\n  // Adds a thread to the threads map\n  addThread: (\n    threadId: string,\n    metadata: ThreadMetadata,\n    totalMessages: number,\n  ) => void;\n  // Removes a thread from the threads map\n  removeThread: (threadId: string) => void;\n\n  // The id of the thread open on this page (or null if none is open)\n  openThread: string | null;\n  setOpenThread: (arg: string | null) => void;\n};\nexport const ThreadsContext = createContext<ThreadsContextType | undefined>(\n  undefined,\n);\n\nexport function ThreadsProvider({ children }: PropsWithChildren) {\n  const [threads, setThreads] = useState<\n    Map<string, { metadata: ThreadMetadata; totalMessages: number }>\n  >(new Map());\n  const addThread = useCallback(\n    (threadId: string, metadata: ThreadMetadata, totalMessages: number) =>\n      setThreads((oldThreads) => {\n        if (oldThreads.has(threadId)) {\n          return oldThreads;\n        }\n        const newThreads = new Map(oldThreads);\n        newThreads.set(threadId, { metadata, totalMessages });\n        return newThreads;\n      }),\n    [],\n  );\n  const removeThread = useCallback(\n    (threadId: string) =>\n      setThreads((oldThreads) => {\n        if (!oldThreads.has(threadId)) {\n          return oldThreads;\n        }\n        const newThreads = new Map(oldThreads);\n        newThreads.delete(threadId);\n        return newThreads;\n      }),\n    [],\n  );\n\n  // Fetch existing threads associated with location\n  const {\n    threads: threadSummaries,\n    hasMore,\n    loading,\n    fetchMore,\n  } = thread.useLocationData(LOCATION, { includeResolved: false });\n  useEffect(() => {\n    if (loading) {\n      return;\n    }\n    if (hasMore) {\n      // NOTE: For this demo, fetch all threads on the page.\n      void fetchMore(1000);\n    }\n    threadSummaries\n      .filter((t) => t.total > 0 && !t.resolved)\n      .forEach((t) => addThread(t.id, t.metadata as ThreadMetadata, t.total));\n  }, [addThread, fetchMore, hasMore, loading, threadSummaries, threads]);\n\n  const [openThread, setOpenThread] = useState<string | null>(null);\n\n  const context = useMemo(\n    () => ({\n      threads,\n      addThread,\n      removeThread,\n      openThread,\n      setOpenThread,\n    }),\n    [threads, addThread, removeThread, openThread],\n  );\n  return (\n    <ThreadsContext.Provider value={context}>\n      {children}\n    </ThreadsContext.Provider>\n  );\n}\n",
    'src/components/AddCommentIcon.tsx':
      'export function AddCommentIcon() {\n  return (\n    <svg\n      xmlns="http://www.w3.org/2000/svg"\n      width="20"\n      height="20"\n      viewBox="0 0 20 20"\n      fill="none"\n    >\n      <path\n        fillRule="evenodd"\n        clipRule="evenodd"\n        d="M10 2C7.79954 1.99932 5.60254 2.17455 3.43 2.524C1.993 2.756 1 4.013 1 5.426V10.573C1 11.986 1.993 13.244 3.43 13.477C4.28298 13.614 5.14007 13.7241 6 13.807V17.25C5.99993 17.3983 6.04385 17.5433 6.12619 17.6667C6.20854 17.7901 6.32561 17.8863 6.46261 17.9431C6.59962 17.9999 6.7504 18.0149 6.89589 17.986C7.04138 17.9572 7.17505 17.8858 7.28 17.781L10.859 14.201C11.0002 14.062 11.1889 13.9819 11.387 13.977C13.1235 13.9195 14.8546 13.7521 16.57 13.476C18.007 13.244 19 11.987 19 10.574V5.426C19 4.014 18.007 2.755 16.57 2.524C14.43 2.18 12.236 2 10 2ZM9.25 7.25V5H10.75V7.25H13V8.75H10.75V11H9.25V8.75H7V7.25H9.25Z"\n        fill="white"\n      />\n    </svg>\n  );\n}\n',
    'src/components/AnimatedText.tsx':
      "import { useState, useEffect } from 'react';\n\n/**\n * Given a string, it will animate it like it's being typed on a GDoc.\n * It only animates it when the document is visible.\n */\nexport function AnimatedText({\n  text,\n  typingUser,\n  animate = true,\n  onComplete,\n}: {\n  text: string;\n  typingUser: string;\n  animate?: boolean;\n  onComplete?: () => void;\n}) {\n  // To achieve the typing animation, we start from an empty string,\n  // and we progressively add some characters.\n  const [currentText, setCurrentText] = useState('');\n  // To add to the realism, we add a fake caret/text cursor, which\n  // resembles the one in GDocs.\n  const [showFakeTextCursor, setShowFakeTextCursor] = useState(false);\n\n  useEffect(() => {\n    if (!animate) {\n      setShowFakeTextCursor(false);\n      return;\n    }\n\n    const stillTyping = currentText.length < text.length;\n    if (stillTyping) {\n      setShowFakeTextCursor(true);\n      setTimeout(() => {\n        setCurrentText((prevText) => text.slice(0, prevText.length + 1));\n      }, getTypingDelay());\n    } else {\n      onComplete?.();\n      setTimeout(() => {\n        setShowFakeTextCursor(false);\n      }, 2000);\n    }\n  }, [animate, currentText.length, onComplete, text]);\n\n  return (\n    <>\n      {currentText}\n      {showFakeTextCursor && (\n        <span data-typing-user={typingUser} className=\"caret\">\n          |\n        </span>\n      )}\n    </>\n  );\n}\n\n/** How fast/slow do we want the typing effect */\nfunction getTypingDelay(delayMs = 50) {\n  return Math.random() * delayMs;\n}\n",
    'src/components/CommentButton.tsx':
      "import { AddCommentIcon } from './AddCommentIcon';\nimport type { Coordinates } from './Document';\n\nconst COMMENT_BUTTON_MARGIN_PX = 4;\n\nexport function CommentButton({\n  coords,\n  onClick,\n}: {\n  coords: Coordinates;\n  onClick: () => void;\n}) {\n  return (\n    <button\n      type=\"button\"\n      className=\"comment-button\"\n      style={{\n        top: coords.top,\n        left: coords.left,\n        transform: `translateY(calc(-100% - ${COMMENT_BUTTON_MARGIN_PX}px))`,\n      }}\n      onClick={onClick}\n    >\n      <AddCommentIcon />\n      <span style={{ userSelect: 'none' }}>Add comment</span>\n    </button>\n  );\n}\n",
    'src/components/Document.tsx':
      "import { Thread, user, presence, PagePresence } from '@cord-sdk/react';\nimport React, {\n  useMemo,\n  useRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useState,\n  Fragment,\n} from 'react';\nimport type { ThreadMetadata } from '../ThreadsContext';\nimport { ThreadsContext } from '../ThreadsContext';\nimport { CommentButton } from './CommentButton';\nimport { FakeMenu } from './FakeMenuIcon';\nimport { FloatingPresence } from './FloatingPresence';\nimport { TextHighlight } from './TextHighlight';\nimport { AnimatedText } from './AnimatedText';\n\nexport const LOCATION = { page: 'document' };\nconst THREADS_GAP = 16;\nexport type Coordinates = { top: number; left: number };\n\n/**\n * A GDocs clone, powered by Cord.\n */\nexport function Document() {\n  // The comment button is shown after user select some text.\n  const [commentButtonCoords, setCommentButtonCoords] = useState<\n    Coordinates | undefined\n  >();\n  // Threads are positioned to the right of the text, just like in GDocs.\n  const [threadsPositions, setThreadsPositions] = useState<Coordinates[]>([]);\n  // Threads which have been rendered on screen. This is useful because\n  // we initially render threads as `hidden`, because we need to know\n  // their height to position them correctly.\n  const [threadsReady, setThreadsReady] = useState<Set<string>>(new Set());\n  const threadsRefs = useRef<(HTMLDivElement | undefined)[] | null>([]);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  // NOTE: This is used only for the typing effect in cord.com demos.\n  // Feel free to ignore/get rid of this part.\n  const [animatingElementIndex, setAnimatingElementIndex] = useState(0);\n  const [finishedTextAnimation, setFinishedTextAnimation] = useState(false);\n  const handleStartAnimatingNextElement = useCallback(\n    () => setAnimatingElementIndex((prev) => prev + 1),\n    [],\n  );\n\n  // We want the sheet to grow as tall as needed, so\n  // that threads can never go outside of it.\n  const infiniteScrollContainerRef = useRef<HTMLDivElement>(null);\n  const [containerHeight, setContainerHeight] = useState(0);\n  const handleUpdateContainerHeight = useCallback(() => {\n    const bottomMostThread =\n      threadsRefs.current?.[threadsRefs.current?.length - 1];\n    setContainerHeight(\n      window.scrollY + (bottomMostThread?.getBoundingClientRect()?.bottom ?? 0),\n    );\n  }, []);\n  useEffect(() => {\n    window.addEventListener('scroll', handleUpdateContainerHeight);\n    return () =>\n      window.removeEventListener('scroll', handleUpdateContainerHeight);\n  }, [handleUpdateContainerHeight]);\n\n  const userData = user.useViewerData();\n  const orgId = userData?.organizationID;\n  const { threads, openThread, addThread, removeThread, setOpenThread } =\n    useContext(ThreadsContext)!;\n\n  // Sorted from top to bottom as they should appear on screen.\n  const sortedThreads = useMemo(() => {\n    // We want to recompute this when the finishedTextAnimation,\n    // because the content of the page changes based on that.\n    // You can remove the next line.\n    finishedTextAnimation;\n    return Array.from(threads).sort(\n      ([_aId, { metadata: metadataA }], [_bId, { metadata: metadataB }]) =>\n        (getRange(metadataA)?.getBoundingClientRect().top ?? 0) -\n        (getRange(metadataB)?.getBoundingClientRect().top ?? 0),\n    );\n  }, [threads, finishedTextAnimation]);\n\n  // If users comment on the same line, multiple threads would have the same\n  // y (or top) coordinate. However, we don't want threads to overlap, and so\n  // we have to manually calculate the positions.\n  // Each thread only cares about the thread above itself. And so, if\n  // the above thread (top coordinate + height) is over the current thread,\n  // we shift the current thread down just enough to not overlap.\n  const getThreadsPositions = useCallback(() => {\n    if (!threadsRefs.current?.length || !sortedThreads.length) {\n      return;\n    }\n\n    const containerRect = containerRef.current?.getBoundingClientRect();\n    if (!containerRect) {\n      return;\n    }\n\n    const [_topThreadId, { metadata }] = sortedThreads[0];\n    const newThreadPositions: Coordinates[] = [\n      {\n        top: getTopPxFromMetadata(metadata),\n        left: containerRect.right + THREADS_GAP,\n      },\n    ];\n    for (let i = 1; i < sortedThreads.length; i++) {\n      const threadAboveIdx = i - 1;\n      const threadAboveTopPx = newThreadPositions[threadAboveIdx].top;\n      const threadAboveRef = threadsRefs.current[threadAboveIdx];\n      const threadAboveHeight =\n        threadAboveRef?.getBoundingClientRect().height ?? 0;\n      const [_threadId, { metadata: currentThreadMetadata }] = sortedThreads[i];\n\n      const currentThreadTopPx = getTopPxFromMetadata(currentThreadMetadata);\n\n      const shouldShiftThreadDown =\n        newThreadPositions[threadAboveIdx].top +\n          threadAboveHeight +\n          THREADS_GAP >\n        currentThreadTopPx;\n\n      newThreadPositions[i] = {\n        top: shouldShiftThreadDown\n          ? threadAboveTopPx + threadAboveHeight + THREADS_GAP\n          : currentThreadTopPx,\n        left: containerRect.right + THREADS_GAP,\n      };\n    }\n\n    // When users open a thread, scroll all the threads upwards,\n    // such that the open thread sits next to the commented line.\n    if (openThread) {\n      const openThreadIdx = sortedThreads.findIndex(\n        ([threadId]) => threadId === openThread,\n      )!;\n      const openThreadInitialTopPx = getTopPxFromMetadata(\n        sortedThreads[openThreadIdx][1].metadata,\n      );\n      const openThreadShiftedTopPx = newThreadPositions[openThreadIdx].top;\n\n      if (openThreadInitialTopPx - openThreadShiftedTopPx < 0) {\n        const amountShifted = openThreadInitialTopPx - openThreadShiftedTopPx;\n\n        for (const threadPosition of newThreadPositions) {\n          threadPosition.top += amountShifted;\n        }\n      }\n    }\n\n    return newThreadPositions;\n  }, [openThread, sortedThreads]);\n\n  const handleUpdateThreadPositions = useCallback(() => {\n    setThreadsPositions((prev) => {\n      const newPositions = getThreadsPositions();\n      if (newPositions) {\n        return newPositions;\n      } else {\n        return prev;\n      }\n    });\n  }, [getThreadsPositions]);\n\n  // We wil observe each thread's dimension, because if their height\n  // changes, we'll want to recompute the thread positions to avoid overlapping.\n  const observer = useMemo(() => {\n    return new ResizeObserver(handleUpdateThreadPositions);\n  }, [handleUpdateThreadPositions]);\n  useEffect(() => {\n    const threadPos = getThreadsPositions();\n    if (threadPos) {\n      setThreadsPositions(threadPos);\n    }\n\n    return () => observer.disconnect();\n  }, [getThreadsPositions, observer, sortedThreads, threadsReady]);\n\n  // Resizing the window should re-adjust the threads' positions\n  useEffect(() => {\n    window.addEventListener('resize', handleUpdateThreadPositions);\n\n    return () => {\n      window.removeEventListener('resize', handleUpdateThreadPositions);\n    };\n  }, [handleUpdateThreadPositions]);\n\n  // When users select text within the page, we want to show a\n  // comment button.\n  const handleSelection = useCallback(() => {\n    const selection = document.getSelection();\n    if (\n      !selection ||\n      selection.isCollapsed ||\n      // Only allow selection in the sheet.\n      !selection.anchorNode?.parentElement?.closest('#sheet') ||\n      !selection.focusNode?.parentElement?.closest('#sheet')\n    ) {\n      setCommentButtonCoords(undefined);\n      return;\n    }\n\n    const hasSelectedText = selection.toString().trim().length > 0;\n    if (hasSelectedText) {\n      const range = selection.getRangeAt(0);\n      const { top, left } = range.getClientRects()[0];\n      setCommentButtonCoords({\n        top: top,\n        left: left,\n      });\n    }\n  }, []);\n  useEffect(() => {\n    document.addEventListener('selectionchange', handleSelection);\n\n    return () => {\n      document.removeEventListener('selectionchange', handleSelection);\n    };\n  }, [handleSelection]);\n\n  const presentUsers = presence.useLocationData(LOCATION, {\n    partial_match: true,\n    exclude_durable: true,\n  });\n  // When users hover on an element, we mark them as present\n  // on that element, and mark them as absent from everywhere else.\n  // We do so by checking the element.id.\n  const handleMouseOver = useCallback((e: MouseEvent) => {\n    if (!window.CordSDK) {\n      return;\n    }\n\n    const toElement = e.target;\n    if (\n      !toElement ||\n      !(toElement instanceof HTMLElement) ||\n      !toElement.id.length ||\n      toElement.id === 'sheet'\n    ) {\n      return;\n    }\n\n    void window.CordSDK.presence.setPresent(\n      {\n        ...LOCATION,\n        elementId: toElement.id,\n      },\n      // This makes a user present only in one place within LOCATION.\n      // E.g. when hovering the title, the user will be marked absent\n      // everywhere else.\n      { exclusive_within: LOCATION },\n    );\n  }, []);\n\n  useEffect(() => {\n    const { current: sheet } = containerRef;\n    if (!sheet) {\n      return;\n    }\n\n    sheet.addEventListener('mouseover', handleMouseOver);\n\n    return () => {\n      sheet.removeEventListener('mouseover', handleMouseOver);\n    };\n  }, [handleMouseOver]);\n\n  // When adding a comment, we want to save enough metadata to be able to\n  // then recreate a `Range`. We can leverage the `Range` to draw highlights\n  // over the text, and have the browser compute their position for us.\n  const addComment = useCallback(() => {\n    if (!orgId) {\n      throw new Error('org information not ready');\n    }\n    const range = window.getSelection()?.getRangeAt(0);\n    if (!range) {\n      return;\n    }\n    const { startContainer, endContainer, startOffset, endOffset } = range;\n    const startElement =\n      startContainer instanceof HTMLElement\n        ? startContainer\n        : startContainer.parentElement;\n    const endElement =\n      endContainer instanceof HTMLElement\n        ? endContainer\n        : endContainer.parentElement;\n\n    if (!startElement || !endElement) {\n      console.warn(`Couldn't add a comment: missing start and end element.`);\n      return;\n    }\n\n    const metadata = {\n      // For simplicity, we've added an id to our elements. This\n      // makes it easy to retrieve the HTMLElement when we need to render\n      // the threads on screen.\n      startNodeId: startElement.id,\n      endNodeId: endElement.id,\n      startOffset,\n      endOffset,\n    } as const;\n    const threadId = crypto.randomUUID();\n    addThread(threadId, metadata, 0);\n    setOpenThread(threadId);\n  }, [addThread, orgId, setOpenThread]);\n\n  const handleRemoveThread = useCallback(\n    (threadId: string) => {\n      setThreadsReady((prev) => {\n        const newThreads = new Set([...prev]);\n        newThreads.delete(threadId);\n        return newThreads;\n      });\n      removeThread(threadId);\n      setOpenThread(null);\n    },\n    [removeThread, setOpenThread],\n  );\n\n  // Improving the UX: Clicking Escape should close the currently open thread.\n  const handleClickEsc = useCallback(\n    (e: KeyboardEvent) => {\n      if (!openThread || e.key !== 'Escape') {\n        return;\n      }\n\n      if (openThread && threads.get(openThread)?.totalMessages === 0) {\n        handleRemoveThread(openThread);\n      } else {\n        setOpenThread(null);\n      }\n    },\n    [handleRemoveThread, openThread, setOpenThread, threads],\n  );\n  useEffect(() => {\n    document.addEventListener('keydown', handleClickEsc);\n\n    return () => {\n      document.removeEventListener('keydown', handleClickEsc);\n    };\n  }, [handleClickEsc]);\n\n  return (\n    <>\n      {commentButtonCoords && (\n        <CommentButton coords={commentButtonCoords} onClick={addComment} />\n      )}\n      <div>\n        {sortedThreads.map(([threadId, { metadata }], threadIdx) => {\n          const range = getRange(metadata);\n          if (!range) {\n            return;\n          }\n          const selectionRects = [...range.getClientRects()];\n          const isOpenThread = openThread === threadId;\n\n          return (\n            <Fragment key={threadId}>\n              {selectionRects.map((rect, idx) => (\n                <TextHighlight\n                  rect={rect}\n                  key={idx}\n                  isOpenThread={isOpenThread}\n                  onClick={() => {\n                    if (!isOpenThread) {\n                      setOpenThread(threadId);\n                    }\n                  }}\n                />\n              ))}\n              <div\n                ref={(el: HTMLDivElement) => {\n                  if (threadsRefs?.current && el) {\n                    threadsRefs.current[threadIdx] = el;\n                    observer.observe(el);\n                  }\n                }}\n                onClick={() => {\n                  setOpenThread(threadId);\n                  // Threads grow vertically. Very long threads might get\n                  // far away from the sheet's content, in which case, move them up!\n                  const isBottomThreadTooFarDown =\n                    threadsPositions[threadsPositions.length - 1].top >\n                    window.innerHeight;\n                  if (isBottomThreadTooFarDown) {\n                    window.scrollTo({ top: 0 });\n                  }\n                }}\n                style={{\n                  position: 'absolute',\n                  left:\n                    (threadsPositions[threadIdx]?.left ??\n                      // Make threads slide in from the right\n                      containerRef.current?.getBoundingClientRect().right ??\n                      0) + (isOpenThread ? -THREADS_GAP * 2 : THREADS_GAP),\n                  top:\n                    threadsPositions[threadIdx]?.top ??\n                    getTopPxFromMetadata(metadata),\n                  transition: 'all 0.25s ease 0.1s',\n                  transitionProperty: 'top, left',\n                  // The first time the thread gets rendered it's `hidden`, but\n                  // it has the right height. Once we know its height, we mark it\n                  // as ready, and we can correctly compute the position of the  thread\n                  //  below it.\n                  visibility: threadsReady.has(threadId) ? 'visible' : 'hidden',\n                }}\n              >\n                <Thread\n                  location={LOCATION}\n                  threadId={threadId}\n                  metadata={metadata}\n                  className={isOpenThread ? 'open-thread' : undefined}\n                  showPlaceholder={false}\n                  composerExpanded={isOpenThread}\n                  autofocus={isOpenThread}\n                  onRender={() =>\n                    setThreadsReady((prev) => new Set([...prev, threadId]))\n                  }\n                  onResolved={() => {\n                    handleRemoveThread(threadId);\n                  }}\n                  onClose={() => {\n                    setOpenThread(null);\n                  }}\n                  onThreadInfoChange={({ messageCount }) => {\n                    const userDeletedLastMessage =\n                      messageCount === 0 && threadsReady.has(threadId);\n                    if (userDeletedLastMessage) {\n                      handleRemoveThread(threadId);\n                    }\n                  }}\n                />\n              </div>\n            </Fragment>\n          );\n        })}\n      </div>\n      <div\n        className=\"container\"\n        ref={infiniteScrollContainerRef}\n        style={{ height: containerHeight }}\n      >\n        <div className=\"header\">\n          <FakeMenu />\n          <PagePresence location={LOCATION} />\n        </div>\n        <hr />\n        {/* Used to catch clicks outside the thread, and close it. */}\n        <div\n          className=\"thread-underlay\"\n          style={{\n            display: openThread ? 'block' : 'none',\n          }}\n          onClick={() => {\n            if (openThread && threads.get(openThread)?.totalMessages === 0) {\n              handleRemoveThread(openThread);\n            } else {\n              setOpenThread(null);\n            }\n          }}\n        />\n        {/* The actual contents of the sheet. If you're planning on building your own,\n        you can safely remove AnimatedText. The key requirement for every element is to have an ID.\n        E.g. <h1 id=\"title\">My Shiny App</h1><p id=\"content\">My Shiny content</p> will work. */}\n        <div id=\"sheet\" ref={containerRef}>\n          <FloatingPresence presentUsers={presentUsers} />\n          <h1 id=\"title\">\n            <AnimatedText\n              typingUser=\"Albert\"\n              animate={!document.hidden && animatingElementIndex === 0}\n              text=\"Looks like Google Docs, right?\"\n              onComplete={handleStartAnimatingNextElement}\n            />\n          </h1>\n          <p id=\"p1\">\n            <AnimatedText\n              typingUser=\"Albert\"\n              animate={!document.hidden && animatingElementIndex === 1}\n              text=\"We built this commenting experience with Cord's SDK, and you\n              can, too 👍\"\n              onComplete={handleStartAnimatingNextElement}\n            />\n          </p>\n          <p id=\"p2\">\n            <AnimatedText\n              typingUser=\"Albert\"\n              animate={!document.hidden && animatingElementIndex === 2}\n              text=\"Go on, give it a try! Don't worry, your comments won't be visible to anyone else visiting the site.\"\n              onComplete={() => setFinishedTextAnimation(true)}\n            />\n          </p>\n        </div>\n      </div>\n    </>\n  );\n}\n\n/**\n * Given ThreadMetadata, build a Range. This is very useful to\n * render the highlight over the text, by leveraging native browser\n * APIs.\n */\nfunction getRange(metadata: ThreadMetadata) {\n  const startElement = document.getElementById(metadata.startNodeId);\n  const endElement = document.getElementById(metadata.endNodeId);\n\n  if (!startElement || !endElement) {\n    return;\n  }\n  const startNode = startElement.firstChild;\n  const endNode = endElement.firstChild;\n  if (!startNode || !endNode) {\n    return;\n  }\n  const range = document.createRange();\n\n  try {\n    range.setStart(startNode, metadata.startOffset);\n    range.setEnd(endNode, metadata.endOffset);\n  } catch (error) {\n    // setEnd throws if we pass an offset greater than the node length.\n    // E.g. user selects 100 chars, text gets edited to only have 50 chars.\n    return null;\n  }\n\n  return range;\n}\n\n/**\n * Helper function that adds the window.scrollY, to correctly account for\n * vertical scroll when comparing the y/top coordinate.\n */\nfunction getTopPxFromMetadata(metadata: ThreadMetadata) {\n  return (\n    (getRange(metadata)?.getBoundingClientRect().top ?? 0) + window.scrollY\n  );\n}\n",
    'src/components/FakeMenuIcon.tsx':
      '/**\n * Looks like GDocs, but it isn\'t!\n */\nexport function FakeMenu() {\n  return (\n    <svg width="262" height="43" fill="none" xmlns="http://www.w3.org/2000/svg">\n      <path\n        d="M.4 21.5c0-9.389 7.61-17 17-17 9.388 0 17 7.611 17 17s-7.612 17-17 17H1.227a.83.83 0 0 1-.829-.83V21.5Z"\n        fill="#2684FC"\n      />\n      <path\n        fillRule="evenodd"\n        clipRule="evenodd"\n        d="M19.606 21.746h1.828v-3.54c1.242 1.488 2.064 2.913 2.401 4.173.383 1.433.142 2.579-.737 3.505-.598.631-1.451.93-2.446.93a5.97 5.97 0 0 1-.921-.075 7.235 7.235 0 0 0-.185-1.744c-.402-1.798-1.43-3.64-2.897-5.186-1.207-1.273-2.528-2.294-3.719-2.874-1.885-.92-2.877-.482-3.378.046-.502.528-.916 1.576-.045 3.564.552 1.258 1.53 2.663 2.738 3.938 1.616 1.701 3.427 2.933 5.273 3.631-.079.126-.16.226-.233.304-.348.366-1.176.92-2.824.508-1.378-.344-2.815-1.248-4.043-2.544l-1.293 1.364c1.464 1.546 3.211 2.633 4.915 3.057a6.32 6.32 0 0 0 1.519.197c1.214 0 2.256-.415 3.018-1.219a3.97 3.97 0 0 0 .762-1.157c.454.08.894.12 1.317.12 1.51 0 2.8-.507 3.736-1.496 1.35-1.424 1.767-3.29 1.204-5.393-.417-1.556-1.353-3.209-2.79-4.926H26V15h-6.395v6.746Zm-4.245-.569c1.228 1.297 2.08 2.808 2.406 4.262.062.277.1.532.12.767-1.458-.603-2.98-1.644-4.349-3.086-.983-1.037-1.799-2.172-2.278-3.179-.461-.968-.447-1.469-.411-1.59.115-.039.59-.053 1.508.433.954.506 2.02 1.355 3.004 2.393Z"\n        fill="#fff"\n      />\n      <path\n        d="M57.41 11.93h1.688a5.382 5.382 0 0 1-.694 2.172 4.06 4.06 0 0 1-1.59 1.52c-.686.37-1.542.554-2.567.554-.75 0-1.433-.14-2.048-.422a4.55 4.55 0 0 1-1.573-1.195 5.594 5.594 0 0 1-1.02-1.872c-.234-.733-.351-1.547-.351-2.444V8.97c0-.897.117-1.708.351-2.435.24-.732.583-1.36 1.029-1.88a4.588 4.588 0 0 1 1.626-1.205c.632-.281 1.344-.422 2.135-.422.967 0 1.784.182 2.452.545a3.903 3.903 0 0 1 1.556 1.512c.375.639.606 1.38.694 2.224h-1.687c-.082-.598-.235-1.11-.457-1.538a2.376 2.376 0 0 0-.95-1.002c-.41-.235-.946-.352-1.608-.352-.568 0-1.07.108-1.503.325a3.026 3.026 0 0 0-1.08.923 4.291 4.291 0 0 0-.651 1.433 7.284 7.284 0 0 0-.22 1.854v1.292c0 .627.065 1.216.194 1.767.134.55.336 1.034.606 1.45.27.416.612.744 1.028.984.416.235.908.352 1.477.352.72 0 1.295-.114 1.722-.343.428-.228.75-.556.967-.984.223-.428.381-.94.475-1.538Zm3.323-.58v-.202c0-.685.1-1.32.299-1.907.2-.592.486-1.104.861-1.538.375-.44.83-.78 1.363-1.02a4.242 4.242 0 0 1 1.793-.369c.668 0 1.268.123 1.801.37.54.24.996.58 1.371 1.02.381.433.671.945.87 1.537.2.586.3 1.222.3 1.907v.203c0 .685-.1 1.32-.3 1.907a4.561 4.561 0 0 1-.87 1.538 3.995 3.995 0 0 1-1.362 1.02c-.527.24-1.125.36-1.793.36-.668 0-1.268-.12-1.802-.36a4.077 4.077 0 0 1-1.37-1.02 4.645 4.645 0 0 1-.862-1.538 5.89 5.89 0 0 1-.299-1.907Zm1.626-.202v.203c0 .474.056.922.167 1.344.111.416.278.785.501 1.108.229.322.513.577.853.764.34.182.735.273 1.186.273.445 0 .835-.091 1.17-.273.339-.187.62-.442.843-.764a3.54 3.54 0 0 0 .5-1.108 4.97 4.97 0 0 0 .177-1.344v-.203c0-.468-.059-.91-.176-1.327a3.417 3.417 0 0 0-.51-1.116 2.423 2.423 0 0 0-.844-.773c-.334-.188-.726-.282-1.177-.282-.446 0-.838.094-1.178.282a2.53 2.53 0 0 0-.844.773 3.53 3.53 0 0 0-.5 1.116 5.116 5.116 0 0 0-.168 1.327Zm10.696-3.164V16H71.43V6.49h1.582l.044 1.494Zm2.971-1.546-.009 1.511a2.347 2.347 0 0 0-.386-.053 4.112 4.112 0 0 0-.405-.017c-.375 0-.706.059-.993.176-.287.117-.53.28-.73.492-.199.21-.357.463-.474.756a3.631 3.631 0 0 0-.22.949l-.457.264c0-.575.056-1.114.167-1.618.117-.503.296-.949.536-1.335.24-.393.545-.698.914-.915.376-.222.82-.334 1.336-.334.118 0 .252.015.405.044a1.2 1.2 0 0 1 .316.08Zm7.321 7.716V2.5h1.635V16h-1.494l-.14-1.846Zm-6.398-2.803v-.185c0-.726.088-1.386.264-1.978a4.79 4.79 0 0 1 .764-1.538 3.46 3.46 0 0 1 1.187-.984 3.375 3.375 0 0 1 1.547-.352c.597 0 1.119.106 1.564.317a3.01 3.01 0 0 1 1.143.905c.316.393.565.867.747 1.424.181.557.307 1.186.378 1.89v.808a8.28 8.28 0 0 1-.378 1.881 4.437 4.437 0 0 1-.747 1.424 3.12 3.12 0 0 1-1.143.905c-.451.205-.978.308-1.582.308a3.27 3.27 0 0 1-1.53-.36 3.61 3.61 0 0 1-1.186-1.011 4.928 4.928 0 0 1-.764-1.53 6.736 6.736 0 0 1-.264-1.924Zm1.635-.185v.185c0 .474.047.92.14 1.335.1.416.252.783.457 1.1.206.316.466.565.783.746.316.176.694.264 1.133.264.54 0 .982-.114 1.328-.343.351-.228.632-.53.843-.905a5.23 5.23 0 0 0 .492-1.222v-2.118a4.697 4.697 0 0 0-.307-.932 2.868 2.868 0 0 0-.51-.808c-.205-.24-.46-.43-.764-.572-.3-.14-.654-.21-1.064-.21-.445 0-.83.093-1.151.28a2.243 2.243 0 0 0-.783.757 3.494 3.494 0 0 0-.457 1.107c-.093.416-.14.861-.14 1.336Zm12.313-1.274v1.335h-4.289V9.892h4.29Zm5.3 6.108h-2.672l.018-1.38h2.654c.914 0 1.676-.19 2.285-.571a3.57 3.57 0 0 0 1.371-1.617c.311-.698.466-1.512.466-2.444v-.782c0-.732-.088-1.383-.264-1.951-.175-.574-.433-1.058-.773-1.45-.34-.399-.756-.7-1.248-.906-.486-.205-1.046-.307-1.679-.307h-2.883V3.203h2.883c.838 0 1.603.14 2.294.422a4.927 4.927 0 0 1 1.784 1.204 5.284 5.284 0 0 1 1.161 1.899c.269.738.404 1.57.404 2.496v.764c0 .926-.135 1.761-.404 2.505a5.245 5.245 0 0 1-1.169 1.89 5.107 5.107 0 0 1-1.829 1.204c-.709.275-1.508.413-2.399.413ZM94.43 3.203V16h-1.696V3.203h1.696Zm13.817 12.973a4.678 4.678 0 0 1-1.802-.334 4.09 4.09 0 0 1-1.38-.958 4.259 4.259 0 0 1-.879-1.46 5.353 5.353 0 0 1-.307-1.845v-.369c0-.774.114-1.462.342-2.065.229-.61.539-1.125.932-1.547a3.996 3.996 0 0 1 1.336-.958 3.838 3.838 0 0 1 1.547-.326c.68 0 1.266.118 1.758.352a3.2 3.2 0 0 1 1.221.984c.317.416.551.909.704 1.477a7.06 7.06 0 0 1 .228 1.846v.73h-7.102v-1.328h5.476v-.123a4.023 4.023 0 0 0-.264-1.23 2.203 2.203 0 0 0-.703-.985c-.322-.258-.761-.387-1.318-.387a2.217 2.217 0 0 0-1.819.923 3.444 3.444 0 0 0-.519 1.116c-.123.44-.185.947-.185 1.521v.37c0 .45.062.875.185 1.274.129.392.313.738.554 1.037.246.299.542.533.887.703.352.17.75.255 1.196.255.574 0 1.06-.118 1.459-.352a3.621 3.621 0 0 0 1.046-.94l.984.782c-.205.31-.466.606-.782.888a3.74 3.74 0 0 1-1.169.685c-.457.176-.999.264-1.626.264Zm7.216-7.796V16h-1.635V6.49h1.547l.088 1.89Zm-.334 2.505-.756-.027c.006-.65.091-1.25.255-1.801.164-.557.407-1.04.729-1.45a3.25 3.25 0 0 1 1.204-.95c.481-.228 1.037-.343 1.67-.343.446 0 .856.065 1.231.194.375.123.7.32.975.589.276.27.49.615.642 1.037.152.422.228.931.228 1.53V16h-1.626V9.742c0-.498-.085-.896-.254-1.195a1.461 1.461 0 0 0-.704-.65c-.304-.141-.662-.211-1.072-.211-.48 0-.882.085-1.204.254-.322.17-.58.405-.773.704a3.156 3.156 0 0 0-.422 1.028c-.082.38-.123.785-.123 1.213Zm6.161-.897-1.09.334a4.793 4.793 0 0 1 .255-1.503c.17-.48.413-.908.729-1.283a3.46 3.46 0 0 1 1.187-.888c.469-.222 1.005-.334 1.608-.334.51 0 .961.068 1.354.203.398.134.732.342 1.002.624.275.275.483.63.624 1.063.14.434.211.95.211 1.547V16h-1.635V9.733c0-.533-.085-.946-.255-1.239a1.326 1.326 0 0 0-.703-.624c-.299-.123-.656-.184-1.072-.184a2.31 2.31 0 0 0-.95.184 1.969 1.969 0 0 0-.694.51c-.187.21-.331.454-.431.73-.093.275-.14.568-.14.878Zm7.91 1.363v-.203c0-.685.1-1.32.299-1.907a4.528 4.528 0 0 1 .861-1.538c.375-.44.829-.78 1.362-1.02a4.249 4.249 0 0 1 1.793-.369c.668 0 1.269.123 1.802.37.539.24.996.58 1.371 1.02.381.433.671.945.87 1.537.2.586.299 1.222.299 1.907v.203c0 .685-.099 1.32-.299 1.907a4.557 4.557 0 0 1-.87 1.538 3.987 3.987 0 0 1-1.362 1.02c-.527.24-1.125.36-1.793.36-.668 0-1.269-.12-1.802-.36a4.08 4.08 0 0 1-1.371-1.02 4.641 4.641 0 0 1-.861-1.538 5.895 5.895 0 0 1-.299-1.907Zm1.626-.203v.203c0 .474.056.922.167 1.344.111.416.278.785.501 1.108.228.322.513.577.852.764.34.182.736.273 1.187.273.445 0 .835-.091 1.169-.273.34-.187.621-.442.844-.764a3.57 3.57 0 0 0 .501-1.108 5.01 5.01 0 0 0 .175-1.344v-.203c0-.468-.058-.91-.175-1.327a3.442 3.442 0 0 0-.51-1.116 2.425 2.425 0 0 0-.844-.773c-.334-.188-.726-.282-1.178-.282-.445 0-.838.094-1.177.282a2.525 2.525 0 0 0-.844.773 3.51 3.51 0 0 0-.501 1.116 5.13 5.13 0 0 0-.167 1.327ZM146.752 16v1.336h-8.06V16h8.06Zm5.642-1.942 3.771-10.855h1.837L153.264 16h-1.309l.439-1.942ZM148.87 3.203l3.735 10.855.466 1.942h-1.31l-4.728-12.797h1.837Zm18.817 11.461V16h-8.376v-1.169l4.193-4.667c.515-.574.914-1.06 1.195-1.459.287-.404.486-.765.598-1.081a2.86 2.86 0 0 0 .175-.984c0-.422-.087-.803-.263-1.143a1.976 1.976 0 0 0-.756-.826c-.334-.205-.738-.308-1.213-.308-.568 0-1.043.112-1.424.334a2.058 2.058 0 0 0-.844.914c-.187.393-.281.844-.281 1.354h-1.626c0-.72.158-1.38.475-1.978a3.495 3.495 0 0 1 1.406-1.424c.621-.357 1.386-.536 2.294-.536.809 0 1.5.144 2.074.431.574.281 1.014.68 1.319 1.195.31.51.465 1.108.465 1.793a3.6 3.6 0 0 1-.193 1.143 5.78 5.78 0 0 1-.519 1.142 8.761 8.761 0 0 1-.764 1.125c-.287.37-.595.733-.923 1.09l-3.428 3.718h6.416ZM176.459 16v1.336h-8.06V16h8.06Zm3.208-12.797V16h-1.697V3.203h1.697Zm5.361 5.757v1.389h-5.73V8.96h5.73Zm.87-5.757v1.389h-6.6V3.203h6.6Zm3.841 0V16h-1.696V3.203h1.696Zm12.929 0V16h-1.705l-6.443-9.87V16h-1.696V3.203h1.696l6.469 9.897V3.203h1.679Zm7.901 1.134L206.333 16h-1.732l4.878-12.797h1.116l-.026 1.134ZM214.12 16l-4.245-11.663-.027-1.134h1.117L215.86 16h-1.74Zm-.22-4.737v1.388h-7.189v-1.388h7.189Zm11.435 3.357V16h-6.399v-1.38h6.399ZM219.27 3.203V16h-1.696V3.203h1.696Zm11.145 6.689v1.335h-4.289V9.892h4.289Zm9.8 4.772V16h-8.376v-1.169l4.192-4.667c.516-.574.914-1.06 1.195-1.459.287-.404.487-.765.598-1.081.117-.322.176-.65.176-.984a2.45 2.45 0 0 0-.264-1.143 1.976 1.976 0 0 0-.756-.826c-.334-.205-.738-.308-1.213-.308-.568 0-1.043.112-1.423.334a2.053 2.053 0 0 0-.844.914c-.188.393-.281.844-.281 1.354h-1.626c0-.72.158-1.38.474-1.978a3.501 3.501 0 0 1 1.406-1.424c.621-.357 1.386-.536 2.294-.536.809 0 1.5.144 2.075.431.574.281 1.013.68 1.318 1.195.31.51.466 1.108.466 1.793 0 .375-.065.756-.194 1.143-.123.38-.296.762-.518 1.142a8.875 8.875 0 0 1-.765 1.125c-.287.37-.595.733-.923 1.09l-3.427 3.718h6.416ZM248.986 16v1.336h-8.059V16h8.059Zm1.327-.861c0-.276.085-.507.255-.695.176-.193.428-.29.756-.29s.577.097.747.29a.976.976 0 0 1 .264.695c0 .27-.088.498-.264.685-.17.188-.419.281-.747.281s-.58-.093-.756-.28a.984.984 0 0 1-.255-.686Zm3.841 0c0-.276.085-.507.255-.695.176-.193.428-.29.756-.29s.577.097.747.29a.976.976 0 0 1 .264.695c0 .27-.088.498-.264.685-.17.188-.419.281-.747.281s-.58-.093-.756-.28a.984.984 0 0 1-.255-.686Zm3.648 0c0-.276.084-.507.254-.695.176-.193.428-.29.756-.29s.577.097.747.29a.976.976 0 0 1 .264.695c0 .27-.088.498-.264.685-.17.188-.419.281-.747.281s-.58-.093-.756-.28a.983.983 0 0 1-.254-.686ZM50.675 28.047V38h-1.32v-9.953h1.32Zm4.17 4.477v1.08h-4.457v-1.08h4.456Zm.676-4.477v1.08h-5.133v-1.08h5.133Zm2.755 2.556V38h-1.271v-7.396h1.271Zm-1.367-1.961c0-.206.062-.379.184-.52.128-.141.315-.212.561-.212.242 0 .426.07.554.212a.732.732 0 0 1 .198.52.715.715 0 0 1-.198.506c-.128.136-.312.204-.554.204-.246 0-.433-.068-.56-.204a.745.745 0 0 1-.185-.506ZM61.68 27.5V38h-1.27V27.5h1.271Zm5.1 10.637a3.64 3.64 0 0 1-1.401-.26 3.178 3.178 0 0 1-1.074-.745 3.314 3.314 0 0 1-.683-1.135 4.162 4.162 0 0 1-.24-1.435v-.288c0-.601.09-1.137.267-1.606.178-.474.42-.875.725-1.203a3.104 3.104 0 0 1 1.039-.745 2.985 2.985 0 0 1 1.203-.253c.529 0 .984.09 1.367.273.388.183.704.438.95.766.246.323.429.706.547 1.148.119.438.178.916.178 1.436v.567h-5.523v-1.032h4.258v-.096a3.153 3.153 0 0 0-.205-.957 1.721 1.721 0 0 0-.547-.765c-.25-.2-.592-.301-1.025-.301a1.722 1.722 0 0 0-1.415.718 2.687 2.687 0 0 0-.403.868 4.4 4.4 0 0 0-.144 1.182v.288c0 .35.048.68.144.99.1.306.243.575.43.807.192.233.422.415.69.547.274.132.584.199.93.199.447 0 .825-.092 1.135-.274a2.81 2.81 0 0 0 .814-.731l.765.608c-.16.242-.362.472-.608.69a2.89 2.89 0 0 1-.91.534c-.355.136-.776.205-1.264.205Zm27.898-1.21V38h-5.27v-1.073h5.27Zm-5.003-8.88V38h-1.32v-9.953h1.32Zm4.306 4.28v1.072h-4.573v-1.073h4.573Zm.63-4.28v1.08h-5.203v-1.08h5.202Zm6.035 8.518V27.5h1.272V38h-1.162l-.11-1.435Zm-4.976-2.181v-.144c0-.565.068-1.078.205-1.538.141-.465.34-.863.594-1.196.26-.333.568-.588.923-.766a2.63 2.63 0 0 1 1.204-.273c.464 0 .87.082 1.216.246.351.16.647.394.889.704.246.305.44.675.581 1.107.141.433.239.923.294 1.47v.629a6.424 6.424 0 0 1-.294 1.463 3.448 3.448 0 0 1-.581 1.107c-.242.306-.538.54-.889.705-.35.159-.76.239-1.23.239-.433 0-.83-.094-1.19-.28a2.806 2.806 0 0 1-.922-.787 3.83 3.83 0 0 1-.595-1.19 5.235 5.235 0 0 1-.205-1.496Zm1.271-.144v.144c0 .369.037.715.11 1.039.077.323.195.608.355.854.16.246.362.44.608.581.246.137.54.206.882.206.42 0 .764-.09 1.032-.267.274-.178.493-.413.657-.704.164-.292.291-.609.383-.95v-1.648a3.662 3.662 0 0 0-.24-.724 2.225 2.225 0 0 0-.396-.63 1.72 1.72 0 0 0-.595-.444 1.927 1.927 0 0 0-.827-.164 1.75 1.75 0 0 0-.896.219 1.744 1.744 0 0 0-.608.588c-.16.246-.278.533-.356.861a4.72 4.72 0 0 0-.109 1.04Zm8.319-3.637V38h-1.271v-7.396h1.271Zm-1.367-1.961c0-.206.062-.379.185-.52.127-.141.314-.212.56-.212.242 0 .427.07.554.212a.732.732 0 0 1 .198.52.715.715 0 0 1-.198.506c-.127.136-.312.204-.554.204-.246 0-.433-.068-.56-.204a.745.745 0 0 1-.185-.506Zm6.494 1.962v.97h-3.999v-.97h3.999Zm-2.645-1.798h1.265v7.362c0 .25.038.44.116.567a.554.554 0 0 0 .301.253c.123.041.255.062.396.062.105 0 .214-.01.328-.027.119-.023.208-.042.267-.055l.007 1.032a3.004 3.004 0 0 1-.397.089 3.01 3.01 0 0 1-.581.048c-.31 0-.595-.062-.854-.185a1.369 1.369 0 0 1-.622-.615c-.151-.292-.226-.684-.226-1.176v-7.355Zm24.826 7.684 2.933-8.443h1.428L133.245 38h-1.019l.342-1.51Zm-2.741-8.443 2.905 8.442.362 1.511h-1.018l-3.678-9.953h1.429Zm9.625 2.556V38h-1.272v-7.396h1.272Zm-1.367-1.961c0-.206.061-.379.184-.52.128-.141.315-.212.561-.212.241 0 .426.07.554.212a.732.732 0 0 1 .198.52.715.715 0 0 1-.198.506c-.128.136-.313.204-.554.204-.246 0-.433-.068-.561-.204a.744.744 0 0 1-.184-.506Zm6.467 9.495c-.515 0-.983-.087-1.402-.26a3.177 3.177 0 0 1-1.073-.745 3.326 3.326 0 0 1-.684-1.135 4.174 4.174 0 0 1-.239-1.435v-.288c0-.601.089-1.137.267-1.606.177-.474.419-.875.724-1.203a3.114 3.114 0 0 1 1.039-.745 2.989 2.989 0 0 1 1.203-.253c.529 0 .985.09 1.368.273.387.183.704.438.95.766.246.323.428.706.547 1.148.118.438.177.916.177 1.436v.567h-5.523v-1.032h4.259v-.096a3.162 3.162 0 0 0-.205-.957 1.727 1.727 0 0 0-.547-.765c-.251-.2-.593-.301-1.026-.301a1.724 1.724 0 0 0-1.415.718 2.695 2.695 0 0 0-.403.868 4.39 4.39 0 0 0-.143 1.182v.288c0 .35.047.68.143.99.1.306.244.575.431.807.191.233.421.415.69.547.274.132.584.199.93.199.446 0 .825-.092 1.135-.274a2.8 2.8 0 0 0 .813-.731l.766.608c-.16.242-.363.472-.609.69a2.9 2.9 0 0 1-.909.534c-.355.136-.777.205-1.264.205Zm6.227-1.45 1.9-6.083h.834l-.164 1.21L151.415 38h-.814l.178-1.313Zm-1.278-6.083 1.62 6.152.116 1.244h-.854l-2.147-7.396h1.265Zm5.831 6.104 1.545-6.104h1.258L155.988 38h-.848l.192-1.292Zm-1.634-6.104 1.859 5.981.212 1.415h-.806l-1.99-6.2-.164-1.197h.889Zm24.977-2.557V38h-1.32v-9.953h1.32Zm4.169 4.477v1.08h-4.457v-1.08h4.457Zm.677-4.477v1.08h-5.134v-1.08h5.134Zm.896 6.337v-.157c0-.534.077-1.028.232-1.484a3.52 3.52 0 0 1 .67-1.196 2.992 2.992 0 0 1 1.06-.793 3.285 3.285 0 0 1 1.394-.287c.52 0 .987.096 1.402.287.419.187.774.451 1.066.793.296.337.522.736.677 1.196.155.456.232.95.232 1.484v.157c0 .533-.077 1.027-.232 1.483a3.555 3.555 0 0 1-.677 1.197 3.103 3.103 0 0 1-1.06.792c-.41.187-.875.28-1.394.28-.52 0-.987-.093-1.402-.28a3.174 3.174 0 0 1-1.066-.793 3.609 3.609 0 0 1-.67-1.196 4.579 4.579 0 0 1-.232-1.483Zm1.264-.157v.157c0 .369.044.718.13 1.046.087.323.217.61.39.861.178.25.399.449.663.595.264.141.572.212.923.212.346 0 .649-.071.909-.212.264-.146.483-.344.656-.595.173-.25.303-.538.39-.861.091-.328.137-.677.137-1.046v-.157c0-.365-.046-.71-.137-1.033a2.661 2.661 0 0 0-.397-.868 1.876 1.876 0 0 0-.656-.601 1.841 1.841 0 0 0-.916-.22c-.346 0-.651.074-.916.22-.26.145-.478.346-.656.601-.173.25-.303.54-.39.868a4.01 4.01 0 0 0-.13 1.033Zm8.32-2.461V38h-1.265v-7.396h1.231l.034 1.162Zm2.31-1.203-.007 1.175a1.809 1.809 0 0 0-.3-.04 3.203 3.203 0 0 0-.315-.014c-.291 0-.549.045-.772.136a1.599 1.599 0 0 0-.568.383 1.84 1.84 0 0 0-.369.588 2.88 2.88 0 0 0-.171.738l-.355.205c0-.446.043-.866.13-1.257.091-.392.23-.739.417-1.04.187-.305.424-.542.711-.71.291-.174.638-.26 1.039-.26.091 0 .196.011.314.034a.92.92 0 0 1 .246.061Zm2.427 1.51V38h-1.271v-7.396h1.203l.068 1.47Zm-.26 1.949L197.89 34c.005-.506.071-.973.199-1.401.127-.433.316-.81.567-1.128.251-.32.563-.565.937-.739.373-.177.806-.266 1.298-.266.347 0 .666.05.957.15.292.096.545.249.759.458.214.21.381.479.499.807.119.328.178.724.178 1.19V38h-1.265v-4.867c0-.388-.066-.698-.198-.93a1.135 1.135 0 0 0-.547-.506 1.973 1.973 0 0 0-.834-.164c-.374 0-.686.066-.936.198a1.579 1.579 0 0 0-.602.547c-.15.233-.26.5-.328.8a4.46 4.46 0 0 0-.096.944Zm4.792-.698-.847.26c.004-.406.07-.795.198-1.169.132-.374.321-.706.567-.998.251-.292.559-.522.923-.69.365-.174.782-.26 1.251-.26.397 0 .747.052 1.053.157.31.105.569.267.779.485.214.215.376.49.485.827.11.338.165.739.165 1.204V38h-1.272v-4.874c0-.415-.066-.736-.198-.964a1.034 1.034 0 0 0-.547-.485 2.19 2.19 0 0 0-.834-.144c-.278 0-.524.048-.738.144a1.511 1.511 0 0 0-.54.396 1.72 1.72 0 0 0-.335.568c-.073.214-.11.442-.11.683Zm10.849 3.411v-3.807c0-.292-.059-.545-.178-.76a1.165 1.165 0 0 0-.519-.505c-.233-.118-.52-.178-.862-.178-.319 0-.599.055-.841.164-.236.11-.423.253-.56.431a.944.944 0 0 0-.198.574h-1.265c0-.264.068-.526.205-.786.137-.26.333-.494.588-.704.26-.214.57-.383.93-.506a3.66 3.66 0 0 1 1.216-.191c.538 0 1.012.09 1.422.273.415.183.739.458.971.827.237.365.356.823.356 1.374v3.446c0 .246.02.508.061.786.046.278.112.517.198.718V38h-1.319a2.334 2.334 0 0 1-.15-.581 4.613 4.613 0 0 1-.055-.684Zm.219-3.22.013.89h-1.278c-.36 0-.681.029-.964.088a2.216 2.216 0 0 0-.711.253 1.135 1.135 0 0 0-.588 1.025c0 .233.053.445.158.636.104.192.262.344.471.458.214.11.476.164.786.164.388 0 .73-.082 1.026-.246.296-.164.531-.364.704-.601.178-.237.273-.468.287-.69l.54.608a1.846 1.846 0 0 1-.26.635 3.079 3.079 0 0 1-1.401 1.196 2.715 2.715 0 0 1-1.08.206c-.502 0-.941-.098-1.32-.294a2.263 2.263 0 0 1-.875-.786 2.08 2.08 0 0 1-.307-1.115c0-.396.077-.745.232-1.045a2.02 2.02 0 0 1 .67-.76c.292-.204.643-.36 1.053-.464.41-.105.868-.157 1.374-.157h1.47Zm6.131-2.912v.971h-3.999v-.97h3.999Zm-2.645-1.797h1.265v7.362c0 .25.038.44.116.567a.554.554 0 0 0 .301.253c.123.041.255.062.396.062.105 0 .214-.01.328-.027.119-.023.208-.042.267-.055l.007 1.032a3.004 3.004 0 0 1-.397.089 3.01 3.01 0 0 1-.581.048c-.31 0-.595-.062-.854-.185a1.373 1.373 0 0 1-.622-.615c-.151-.292-.226-.684-.226-1.176v-7.355Z"\n        fill="#000"\n      />\n    </svg>\n  );\n}\n',
    'src/components/FloatingPresence.tsx':
      "import type { UserLocationData } from '@cord-sdk/types';\nimport { Avatar } from '@cord-sdk/react';\n\nconst AVATARS_GAP = 12;\n/**\n * Adds an avatar next to the element where the user is present.\n */\nexport function FloatingPresence({\n  presentUsers,\n}: {\n  presentUsers: UserLocationData[] | undefined;\n}) {\n  return (\n    <>\n      {presentUsers?.map((u, idx) => {\n        const { locations } = u.ephemeral;\n        // We made it so user can only be at one location at a time.\n        const elementId = (locations?.[0]?.elementId ?? '') as string;\n        const elementRect = document\n          .getElementById(elementId)\n          ?.getBoundingClientRect();\n        if (!elementRect) {\n          return null;\n        }\n        const { top, left, height } = elementRect;\n        return (\n          <Avatar\n            key={u.id}\n            userId={u.id}\n            style={{\n              position: 'absolute',\n              top: top + window.scrollY + height / 2, // Move it to the middle of the line.\n              transform: 'translateY(-50%)', // Center it visually.\n              left:\n                left -\n                window.scrollX -\n                AVATARS_GAP * 2 - // Move it to the left of the text\n                idx * AVATARS_GAP, // Move each avatar a bit more to the left\n              zIndex: 1,\n              transition: 'top  0.25s ease 0.1s',\n              visibility:\n                !elementId || locations.length <= 0 ? 'hidden' : 'visible',\n            }}\n          />\n        );\n      })}\n    </>\n  );\n}\n",
    'src/components/TextHighlight.tsx':
      "import type { CSSProperties } from 'react';\n\n/**\n * The highlight has two parts: aA yellow rectangle below the text, to not cover it.\n * A clickable transparent rectangle over the text, enabling interactions.\n */\nexport function TextHighlight({\n  rect,\n  isOpenThread,\n  onClick,\n}: {\n  rect: DOMRect;\n  isOpenThread: boolean;\n  onClick: () => void;\n}) {\n  const rectPosition = {\n    width: rect.width,\n    height: rect.height,\n    top: rect.top + window.scrollY,\n    left: rect.left + window.scrollX,\n    position: 'absolute',\n  } as CSSProperties;\n  return (\n    <>\n      <div\n        style={{\n          ...rectPosition,\n          background: isOpenThread ? '#F5BE4D' : '#FDF2D7',\n        }}\n      />\n      <div\n        style={{\n          ...rectPosition,\n          zIndex: 2,\n          cursor: 'pointer',\n        }}\n        onClick={onClick}\n      />\n    </>\n  );\n}\n",
    'src/css/document.css':
      "@import url('https://fonts.googleapis.com/css2?family=Roboto&display=swap');\n\n*,\n*::before,\n*::after {\n  box-sizing: border-box;\n}\n\n* {\n  padding: 0;\n}\n\nbody {\n  background-color: #c2e7ff;\n  font-family: Roboto, -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica,\n    Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';\n\n  --black: #1f1f1f;\n  --grey-light: #dadce0;\n}\n\nhtml,\nbody,\n#root {\n  height: 100%;\n  margin: 0px;\n}\n\n#root {\n  display: flex;\n  justify-content: center;\n}\n\n.container {\n  margin: 80px;\n  padding: 16px 20px;\n  width: 100%;\n  max-width: 1200px;\n  border-radius: 8px;\n  border: 1px solid var(--grey-light);\n  background: #f9fbfd;\n  box-shadow: 0px 2px 2px 0px rgba(0, 0, 0, 0.1),\n    0px 2px 20px 0px rgba(0, 0, 0, 0.16);\n  min-height: 100%;\n  overflow: hidden;\n}\n\n.header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n\nhr {\n  border: 0;\n  border-top: 1px solid #c7c7c7;\n  margin: 8px 0 16px 0;\n}\n\n#sheet {\n  --header-height: 64px;\n  --padding: 48px;\n  align-items: flex-start;\n  background-color: white;\n  border: 1px solid #c7c7c7;\n  border-bottom: none;\n  display: flex;\n  flex-direction: column;\n  min-height: 100%;\n  height: fit-content;\n  margin-left: 5%;\n  margin-right: 350px;\n  padding: var(--padding);\n  max-width: 768px;\n}\n\n#sheet > * {\n  isolation: isolate;\n}\n\n.comment-button {\n  align-items: center;\n  background: var(--black);\n  border-radius: 4px;\n  border: 0;\n  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.16);\n  color: white;\n  cursor: pointer;\n  display: flex;\n  font-size: 14px;\n  gap: 4px;\n  padding: 6px 8px;\n  position: fixed;\n  z-index: 2;\n}\n\n#body {\n  margin: 0;\n  white-space: pre-line;\n}\n\n.caret {\n  color: deeppink;\n  margin-left: -3px;\n}\n.caret::after {\n  content: attr(data-typing-user);\n  position: absolute;\n  background-color: deeppink;\n  color: white;\n  font-size: 12px;\n  transform: translateY(-80%);\n  padding: 2px;\n  border-radius: 4px;\n}\n\ncord-thread.cord-component:hover {\n  z-index: 5;\n}\n\ncord-thread.cord-component.open-thread {\n  z-index: 5;\n  --cord-color-base: unset;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3), 0 4px 8px 3px rgba(0, 0, 0, 0.15);\n  gap: 12px;\n}\n\ncord-thread:not(.open-thread) .cord-composer {\n  display: none;\n}\n\n.thread-underlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  cursor: auto;\n  isolation: isolate;\n}\n\ncord-thread.cord-component {\n  display: flex;\n  width: 256px;\n  padding: 12px;\n  flex-direction: column;\n  border-radius: 16px;\n  border: 0;\n  z-index: 1;\n\n  --cord-color-base: #edf2fa;\n  --cord-color-content-primary: var(--black);\n  --cord-color-content-secondary: var(--black);\n  --cord-color-content-emphasis: var(--black);\n}\n\ncord-thread .cord-thread-container {\n  margin-bottom: -14px;\n}\n\n.cord-message:not(.cord-deleted, .cord-action) {\n  border-radius: 0;\n  gap: 0;\n  grid-template-rows: 18px 16px auto auto;\n  grid-template-columns: 48px auto auto auto 1fr auto;\n  grid-template-areas:\n    'avatar authorName  sentViaIcon . optionsMenu'\n    'avatar timestamp  timestamp . optionsMenu'\n    'messageContent messageContent messageContent messageContent messageContent'\n    'reactions reactions reactions reactions reactions';\n  margin: 0 12px 16px;\n  padding-left: 5px;\n  margin-top: 0;\n  padding: 0;\n}\n\n.cord-component .cord-message-block::first-child {\n  padding-top: 12px;\n}\n\n.cord-message.cord-no-reactions:not(.cord-deleted, .cord-action) {\n  grid-template-rows: 18px 16px auto;\n  grid-template-columns: 48px auto auto auto 1fr auto;\n  grid-template-areas:\n    'avatar authorName  sentViaIcon . optionsMenu'\n    'avatar timestamp  timestamp . optionsMenu'\n    'messageContent messageContent messageContent messageContent messageContent';\n}\n\n.cord-component .cord-message .cord-avatar-container {\n  border-radius: 50%;\n  width: 32px;\n  height: 32px;\n  grid-area: avatar;\n}\n\n.cord-component .cord-message .cord-timestamp {\n  grid-area: timestamp;\n  margin-top: 0;\n}\n\n.cord-component .cord-message .cord-author-name {\n  margin: 0;\n}\n\n.cord-component .cord-message .cord-options-menu-trigger {\n  display: contents;\n}\n\n.cord-component\n  .cord-message\n  .cord-options-menu-trigger\n  .cord-message-options-buttons {\n  display: contents;\n}\n\n.cord-message .cord-message-options-buttons [data-cord-button='select-emoji'] {\n  align-self: end;\n  background: white;\n  border-radius: 50%;\n  box-shadow: 0 2px 3px rgba(0, 0, 0, 0.3);\n  grid-area: messageContent;\n  height: 32px;\n  justify-self: end;\n  translate: 0 30%;\n  width: 32px;\n}\n\n.cord-component\n  .cord-message\n  .cord-options-menu-trigger\n  .cord-message-options-buttons\n  .cord-button[data-cord-button='thread-options'] {\n  background: transparent;\n  border-radius: 50%;\n  grid-area: optionsMenu;\n  height: 32px;\n  justify-self: flex-end;\n  rotate: 90deg;\n  width: 32px;\n}\n\n.cord-component\n  .cord-message\n  .cord-options-menu-trigger\n  .cord-message-options-buttons\n  .cord-button[data-cord-button='thread-options']:hover {\n  background: rgba(68, 71, 70, 0.08);\n}\n\n.cord-component .cord-message .cord-message-content {\n  border-radius: 6px;\n  margin-top: 4px;\n  padding: 6px 32px 3px 0;\n}\n\n.cord-component\n  :is(.cord-scroll-container, .cord-message, .cord-message-content) {\n  background: transparent;\n}\n\n.cord-component .cord-message:hover .cord-message-content {\n  background: rgb(240, 240, 240);\n}\n\n.cord-component .cord-message .cord-reaction-list {\n  margin-top: 5px;\n}\n\n.cord-component .cord-message .cord-reaction-list .cord-pill {\n  align-items: center;\n  background: transparent;\n  border: 1px solid rgb(199, 199, 199);\n  border-radius: 14px;\n  padding: 2px 7px;\n}\n\n.cord-component .cord-message .cord-reaction-list .cord-pill .cord-emoji {\n  font-size: 20px;\n  line-height: 20px;\n}\n\n.cord-component\n  .cord-message\n  .cord-reactions-container\n  [data-cord-button='select-emoji'] {\n  display: none;\n}\n\n.cord-component .cord-message.cord-editing {\n  grid-template-columns: auto 1fr;\n  grid-template-areas: 'avatar messageContent';\n  grid-template-rows: auto;\n}\n\n.cord-component .cord-message.cord-editing .cord-avatar-container {\n  align-self: center;\n}\n\n.cord-component .cord-message .cord-menu {\n  background: white;\n}\n\n.cord-component .cord-thread-seen-by-container {\n  display: none;\n}\n\n.cord-component .cord-composer .cord-placeholder {\n  color: rgb(60, 64, 67);\n}\n\n.cord-component .cord-composer {\n  gap: 0;\n  height: auto;\n  background-color: white;\n  border-radius: 16px;\n  border: 1px solid var(--grey-light);\n  margin: 4px;\n}\n\n.cord-component .cord-editing .cord-composer {\n  grid-area: messageContent;\n}\n\n.cord-component .cord-composer .cord-editor-container {\n  margin: 0px 16px;\n  max-height: none;\n  min-height: 20px;\n}\n\n.cord-component .cord-composer .cord-composer-menu {\n  border: none;\n  padding: 0;\n}\n\n.cord-component .cord-composer .cord-button {\n  display: none;\n}\n\ncord-avatar.cord-component .cord-avatar-container {\n  border-radius: 40px;\n  border: 1px solid #2e2e2e;\n  box-shadow: 0px 2px 4px 0px rgba(0, 0, 0, 0.08);\n}\n\ncord-page-presence.cord-component .cord-avatar-container {\n  border-radius: 50%;\n  width: 34px;\n  height: 34px;\n}\n\ncord-page-presence.cord-component .cord-avatar-container.cord-present {\n  border: 2px solid #b80672;\n}\n\ncord-page-presence.cord-component .cord-facepile {\n  gap: 8px;\n}\n\nemoji-picker.cord-emoji-picker {\n  --background: white;\n}\n",
    'src/main.tsx':
      "import * as ReactDOM from 'react-dom/client';\nimport App from './App';\nimport './css/document.css';\n\nReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(\n  <App />,\n);\n",
    'src/utils.ts':
      "import { useEffect, useState } from 'react';\n\nexport const CORD_TOKEN_LOCALSTORAGE_KEY = 'cord_token';\nconst CORD_SAMPLE_TOKEN_ENDPOINT = 'https://api.cord.com/sample-token';\n\nconst ONE_MINUTE_MS = 60 * 1000;\nconst ONE_DAY_MS = ONE_MINUTE_MS * 60 * 24;\nconst SEVEN_DAYS_MS = ONE_DAY_MS * 7;\n\nfunction canUseLocalStorage() {\n  try {\n    typeof window.localStorage;\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function useCordSampleToken_DEMO_ONLY_NOT_FOR_PRODUCTION() {\n  const [{ value: cordAuthToken, hasExpired }, setCordAuthToken] = useState<{\n    value: string | null;\n    hasExpired: boolean;\n  }>(\n    canUseLocalStorage()\n      ? () => getLocalStorageItemWithExpiry(CORD_TOKEN_LOCALSTORAGE_KEY)\n      : { value: null, hasExpired: true },\n  );\n\n  useEffect(() => {\n    if (!cordAuthToken || hasExpired) {\n      void fetchCordSampleToken().then((token) => {\n        if (token) {\n          setCordAuthToken({ value: token, hasExpired: false });\n\n          if (canUseLocalStorage()) {\n            localStorage.setItem(\n              CORD_TOKEN_LOCALSTORAGE_KEY,\n              withExpiry(\n                token,\n                // Sample token expires after 7 days\n                getTimeInXMillisecondsFromNow(SEVEN_DAYS_MS),\n              ),\n            );\n          } else {\n            console.warn(\n              `Cannot save Cord token in the localStorage. If you refresh the page, you will lose all your messages.`,\n            );\n          }\n        }\n      });\n    }\n  }, [cordAuthToken, hasExpired]);\n\n  return cordAuthToken;\n}\n\nasync function fetchCordSampleToken(): Promise<string | null> {\n  try {\n    const response = await fetch(CORD_SAMPLE_TOKEN_ENDPOINT, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ extended: 'true' }),\n    });\n\n    if (response.status !== 200) {\n      throw new Error('Failed to fetch Cord sample token');\n    }\n\n    const { client_auth_token } = await response.json();\n    return client_auth_token;\n  } catch (e) {\n    return null;\n  }\n}\n\nexport function getLocalStorageItemWithExpiry(key: string) {\n  const itemStr = localStorage.getItem(key);\n  if (!itemStr) {\n    return { value: null, hasExpired: true };\n  }\n\n  try {\n    const item = JSON.parse(itemStr);\n    const isValid = Boolean(item.expiry && item.value);\n    if (!isValid) {\n      localStorage.removeItem(key);\n      return { value: null, hasExpired: true };\n    }\n\n    const hasExpired = new Date().getTime() > item.expiry;\n    return { value: item.value, hasExpired };\n  } catch {\n    localStorage.removeItem(key);\n    return { value: null, hasExpired: true };\n  }\n}\n\nexport function withExpiry(value: string, expiry: number) {\n  const item = {\n    value: value,\n    expiry,\n  };\n\n  return JSON.stringify(item);\n}\n\nfunction getTimeInXMillisecondsFromNow(xMilliseconds: number) {\n  return new Date(new Date().getTime() + xMilliseconds).getTime();\n}\n",
    'tsconfig.json':
      '{\n  "compilerOptions": {\n    "target": "ESNext",\n    "useDefineForClassFields": true,\n    "lib": ["DOM", "DOM.Iterable", "ESNext"],\n    "allowJs": false,\n    "skipLibCheck": true,\n    "esModuleInterop": false,\n    "allowSyntheticDefaultImports": true,\n    "strict": true,\n    "forceConsistentCasingInFileNames": true,\n    "module": "ESNext",\n    "moduleResolution": "Node",\n    "resolveJsonModule": true,\n    "isolatedModules": true,\n    "noEmit": true,\n    "jsx": "react-jsx"\n  },\n  "include": ["src", "main.tsx"],\n  "references": [{ "path": "./tsconfig.node.json" }]\n}\n',
  },
  'dashboard-new': {
    'index.html':
      '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/png" href="/src/images/favicon.png" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Cord Sample App - Dashboard</title>\n  </head>\n  <body>\n    <div id="root"></div>\n    <script type="module" src="/src/main.tsx"></script>\n  </body>\n</html>\n',
    'package.json':
      '{\n  "name": "cord-sample-dashboard",\n  "private": true,\n  "version": "1.0.0",\n  "scripts": {\n    "dev": "vite",\n    "build": "tsc && vite build",\n    "preview": "vite preview"\n  },\n  "dependencies": {\n    "@cord-sdk/react": "^1.15.1",\n    "@floating-ui/react": "^0.24.3",\n    "@floating-ui/react-dom": "^0.7.0",\n    "ag-grid-react": "^28.0.0",\n    "classnames": "^2.3.1",\n    "highcharts": "^10.2.0",\n    "highcharts-react-official": "^3.1.0",\n    "react": "^18.0.0",\n    "react-dom": "^18.0.0"\n  },\n  "devDependencies": {\n    "@cord-sdk/types": "^1.15.1",\n    "@types/react": "^18.2.18",\n    "@types/react-dom": "^18.0.0",\n    "@vitejs/plugin-react": "^1.3.2",\n    "typescript": "~5.1.6",\n    "vite": "^2.9.14"\n  }\n}\n',
    'public/images/comment-cursor-active.svg':
      '<?xml version=\'1.0\' encoding=\'UTF-8\'?>\n<svg version=\'1.1\' xmlns=\'http://www.w3.org/2000/svg\' xmlns:xlink=\'http://www.w3.org/1999/xlink\'\n  width="34"\n  height="34"\n  viewBox="0 0 34 34"\n>\n  <path d="M1 17C1 8.16344 8.16344 1 17 1V1C25.8366 1 33 8.16344 33 17V17C33 25.8366 25.8366 33 17 33H2.88235C1.84276 33 1 32.1572 1 31.1176V17Z" fill="#121314"></path>\n  <path d="M2.88235 33.5H17C26.1127 33.5 33.5 26.1127 33.5 17C33.5 7.8873 26.1127 0.5 17 0.5C7.8873 0.5 0.5 7.8873 0.5 17V31.1176C0.5 32.4334 1.56662 33.5 2.88235 33.5Z" stroke="#FFFFFF" stroke-opacity="1" fill="#339966"></path>\n</svg>\n',
    'public/images/comment-cursor.svg':
      '<?xml version=\'1.0\' encoding=\'UTF-8\'?>\n<svg version=\'1.1\' xmlns=\'http://www.w3.org/2000/svg\' xmlns:xlink=\'http://www.w3.org/1999/xlink\'\n  width="34"\n  height="34"\n  viewBox="0 0 34 34"\n>\n  <path d="M1 17C1 8.16344 8.16344 1 17 1V1C25.8366 1 33 8.16344 33 17V17C33 25.8366 25.8366 33 17 33H2.88235C1.84276 33 1 32.1572 1 31.1176V17Z" fill="#121314"></path>\n  <path d="M2.88235 33.5H17C26.1127 33.5 33.5 26.1127 33.5 17C33.5 7.8873 26.1127 0.5 17 0.5C7.8873 0.5 0.5 7.8873 0.5 17V31.1176C0.5 32.4334 1.56662 33.5 2.88235 33.5Z" stroke="#FFFFFF" stroke-opacity="1"></path>\n</svg>\n',
    'src/App.tsx':
      "import { CordProvider } from '@cord-sdk/react';\nimport type { NavigateFn } from '@cord-sdk/types';\n\nimport { useRef } from 'react';\n\nimport Dashboard from './components/Dashboard';\nimport { useCordSampleToken_DEMO_ONLY_NOT_FOR_PRODUCTION } from './utils';\nimport { ThreadsProvider } from './ThreadsContext';\n\nexport default function App() {\n  const authToken = useCordSampleToken_DEMO_ONLY_NOT_FOR_PRODUCTION();\n  const navigateRef = useRef<NavigateFn | null>(null);\n\n  return (\n    // All the Cord React components must be children of a single CordProvider\n    // component, which is passed the clientAuthToken so the Cord components\n    // know which user they're connecting as. The \"navigate\" function is\n    // optional and used here to make clicking on notifications work better (see\n    // it's actual implementation in Dashboard.tsx).\n    //\n    // All props to CordProvider, along with the Cord init process in general,\n    // are documented here:\n    // https://docs.cord.com/js-apis-and-hooks/initialization\n    <CordProvider\n      clientAuthToken={authToken}\n      navigate={(...args) => navigateRef.current?.(...args) ?? false}\n    >\n      \n      {authToken && (\n        <ThreadsProvider>\n          <Dashboard navigateRef={navigateRef} />\n        </ThreadsProvider>\n      )}\n    </CordProvider>\n  );\n}\n",
    'src/ThreadsContext.tsx':
      "import { thread } from '@cord-sdk/react';\nimport type { PropsWithChildren } from 'react';\nimport {\n  useCallback,\n  useEffect,\n  useState,\n  createContext,\n  useMemo,\n} from 'react';\nimport { LOCATION } from './components/Dashboard';\n\n// Metadata stored on threads left on charts\nexport type ChartThreadMetadata = {\n  type: 'chart';\n  chartId: string;\n  seriesId: string;\n  x: number;\n  y: number;\n  autogenerated?: boolean;\n};\n\n// Metadata stored on threads left on table grids\nexport type GridThreadMetadata = {\n  type: 'grid';\n  gridId: string;\n  rowId: string;\n  colId: string;\n};\n\nexport type ThreadMetadata = ChartThreadMetadata | GridThreadMetadata;\n\n// Context for storing all thread related information\ntype ThreadsContextType = {\n  // Map of all threads on current page, mapping from thread's ID to its\n  // metadata\n  threads: ReadonlyMap<string, ThreadMetadata>;\n  // Adds a thread to the threads map\n  addThread: (threadId: string, metadata: ThreadMetadata) => void;\n  // Removes a thread from the threads map\n  removeThread: (threadId: string) => void;\n\n  // The id of the thread open on this page (or null if none is open)\n  openThread: string | null;\n  setOpenThread: (arg: string | null) => void;\n\n  // The id of the thread that should be open after the page makes necessary\n  // adjustments to make the thread visible. Common adjustments are scrolling\n  // the page, updating chart/table filters, un-collapsing the right page\n  // section etc. This is useful for implementing ThreadList's onThreadClick\n  // callback or for implementing URL deep-linking. If page adjustments are not\n  // needed, then simply use `setOpenThread(threadId)` to open a thread.\n  //\n  // The standard usage pattern looks like this:\n  // useEffect(() => {\n  //    if (requestToOpenThread) {\n  //      ...scroll the page, adjust filters, etc.\n  //      setOpenThread(requestToOpenThread);\n  //      setRequestToOpenThread(null);\n  //   }\n  // }, [requestToOpenThread, setRequestToOpenThread, setOpenThread]);\n  requestToOpenThread: string | null;\n  setRequestToOpenThread: (threadId: string | null) => void;\n};\nexport const ThreadsContext = createContext<ThreadsContextType | undefined>(\n  undefined,\n);\n\nexport function ThreadsProvider({ children }: PropsWithChildren) {\n  const [threads, setThreads] = useState<Map<string, ThreadMetadata>>(\n    new Map(),\n  );\n  const addThread = useCallback(\n    (threadId: string, metadata: ThreadMetadata) =>\n      setThreads((oldThreads) => {\n        if (oldThreads.has(threadId)) {\n          return oldThreads;\n        }\n        const newThreads = new Map(oldThreads);\n        newThreads.set(threadId, metadata);\n        return newThreads;\n      }),\n    [],\n  );\n  const removeThread = useCallback(\n    (threadId: string) =>\n      setThreads((oldThreads) => {\n        if (!oldThreads.has(threadId)) {\n          return oldThreads;\n        }\n        const newThreads = new Map(oldThreads);\n        newThreads.delete(threadId);\n        return newThreads;\n      }),\n    [],\n  );\n\n  // Fetch existing threads associated with location\n  const {\n    threads: threadSummaries,\n    hasMore,\n    loading,\n    fetchMore,\n  } = thread.useLocationData(LOCATION, { includeResolved: false });\n  useEffect(() => {\n    if (loading) {\n      return;\n    }\n    if (hasMore) {\n      // NOTE: For this demo, fetch all threads on the page.\n      void fetchMore(1000);\n    }\n    threadSummaries\n      .filter((t) => t.total > 0)\n      .forEach((t) => addThread(t.id, t.metadata as ThreadMetadata));\n  }, [addThread, fetchMore, hasMore, loading, threadSummaries, threads]);\n\n  const [openThread, setOpenThread] = useState<string | null>(null);\n\n  const [requestToOpenThread, setRequestToOpenThread] = useState<string | null>(\n    null,\n  );\n\n  const context = useMemo(\n    () => ({\n      threads,\n      addThread,\n      removeThread,\n      openThread,\n      setOpenThread,\n      requestToOpenThread,\n      setRequestToOpenThread,\n    }),\n    [threads, addThread, removeThread, openThread, requestToOpenThread],\n  );\n  return (\n    <ThreadsContext.Provider value={context}>\n      {children}\n    </ThreadsContext.Provider>\n  );\n}\n",
    'src/chartData.json':
      '[\n  {\n    "id": "unique-id-of-this-series",\n    "name": "Figma",\n    "data": [\n      55.25, 53.01, 64.5, 86.19, 78.62, 94.43, 122.97, 103.58, 129.99, 152.05,\n      257.58\n    ],\n    "color": "#9a6aff"\n  },\n  {\n    "id": "unique-id-of-this-series-2",\n    "name": "Notion",\n    "data": [\n      null,\n      60.25,\n      82.07,\n      82.54,\n      92.67,\n      102.85,\n      120.64,\n      178.57,\n      176,\n      182,\n      219.92\n    ],\n    "color": "#fa7351"\n  }\n]\n',
    'src/components/AGGridExample.tsx':
      "import {\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { AgGridReact } from 'ag-grid-react';\nimport type { ICellRendererParams, GridApi, ColDef } from 'ag-grid-community';\nimport 'ag-grid-community/dist/styles/ag-grid.css';\nimport 'ag-grid-community/dist/styles/ag-theme-alpine.css';\nimport { PresenceFacepile, PresenceObserver, user } from '@cord-sdk/react';\nimport {\n  autoUpdate,\n  flip,\n  offset,\n  shift,\n  useFloating,\n} from '@floating-ui/react';\nimport chartData from '../chartData.json';\nimport type { GridThreadMetadata } from '../ThreadsContext';\nimport { ThreadsContext } from '../ThreadsContext';\nimport { LOCATION } from './Dashboard';\nimport { ThreadWrapper } from './ThreadWrapper';\nimport commentIcon from './CommentIcon.svg';\n\nexport function AGGridExample({ gridId }: { gridId: string }) {\n  const orgId = user.useViewerData()?.organizationID;\n  const gridRef = useRef<AgGridReact>(null);\n  const gridContainerRef = useRef<HTMLDivElement>(null);\n\n  const onGridReady = useCallback(() => {\n    const element = gridContainerRef.current;\n\n    if (!element) {\n      return;\n    }\n\n    // the grid needs to be manually resized when the page is resized\n    const resizeObserver = new ResizeObserver(() => {\n      gridRef.current?.api.sizeColumnsToFit();\n    });\n    resizeObserver.observe(element);\n  }, []);\n\n  const {\n    openThread,\n    addThread,\n    setOpenThread,\n    threads,\n    requestToOpenThread,\n    setRequestToOpenThread,\n  } = useContext(ThreadsContext)!;\n\n  // Effect to show the correct thread when the user requests to open a\n  // specific thread (e.g. by clicking a thread in ThreadList)\n  useEffect(() => {\n    const grid = gridRef.current;\n    if (!grid) {\n      // this should not happen, appease typechecker\n      return;\n    }\n    const metadata =\n      requestToOpenThread !== null ? threads.get(requestToOpenThread) : null;\n    if (metadata?.type === 'grid' && metadata.gridId === gridId) {\n      // this is a request for this grid, make the thread visible\n      const { rowId, colId } = metadata;\n      const rowNode = grid.api.getRowNode(rowId);\n\n      if (!rowNode) {\n        // unknown rowId, may want to take a custom action, such as display\n        // thread in a full page modal\n        return;\n      }\n\n      if (!rowNode.displayed) {\n        // remove filters to make sure the row is displayed\n        grid.api.setFilterModel(null);\n      }\n      grid.api.ensureNodeVisible(rowNode); // scroll the table\n\n      // Scroll the page to the table, open the thread and flash the table cell\n      gridContainerRef.current?.scrollIntoView({\n        behavior: 'smooth',\n        block: 'center',\n      });\n\n      setRequestToOpenThread(null);\n\n      // Only open the thread if the table is in the viewport because\n      // opening the thread immediately currently stops the scrollIntoView().\n      const openThreadIfInView = () => {\n        const gridContainerBottom =\n          gridContainerRef.current?.getBoundingClientRect().bottom;\n        const gridContainerTop =\n          gridContainerRef.current?.getBoundingClientRect().top;\n\n        if (\n          gridContainerBottom &&\n          gridContainerTop &&\n          // Open the thread if the whole table container is in the viewport\n          ((window.innerHeight > gridContainerBottom &&\n            window.innerHeight > gridContainerTop) ||\n            // Also open the thread if the top of the table is outside the viewport\n            // to account for window heights smaller than the table height\n            gridContainerTop < 0)\n        ) {\n          grid.api.flashCells({ rowNodes: [rowNode], columns: [colId] });\n          clearInterval(intervalID);\n          setOpenThread(requestToOpenThread);\n        }\n      };\n\n      // Check every 150ms to see if we have scrolled the table into view\n      const intervalID = setInterval(openThreadIfInView, 150);\n\n      // If for some reason we never open a thread then give up and clean up the setInterval after 2s\n      setTimeout(() => clearInterval(intervalID), 2000);\n    }\n  }, [\n    threads,\n    gridId,\n    requestToOpenThread,\n    setOpenThread,\n    setRequestToOpenThread,\n  ]);\n\n  const openThreadMetadata =\n    openThread !== null ? threads.get(openThread) : null;\n  const threadOpenOnThisGrid =\n    openThreadMetadata?.type === 'grid' && openThreadMetadata.gridId === gridId;\n  const { refs, floatingStyles } = useFloating({\n    open: threadOpenOnThisGrid,\n    middleware: [offset(10), flip(), shift()],\n    whileElementsMounted: autoUpdate,\n    transform: false, // allow Thread to use position: fixed for attachment previews\n  });\n\n  const [rowOfOpenThreadVisible, setRowOfOpenThreadVisible] = useState(true);\n\n  // Effect to re-calculate whether the open thread's row is visible\n  useEffect(() => {\n    if (gridRef.current?.api && threadOpenOnThisGrid) {\n      setRowOfOpenThreadVisible(\n        // NOTE: same logic is needed for columns if horizontal scrolling is allowed\n        isRowInScrollView(gridRef.current.api, openThreadMetadata.rowId),\n      );\n    }\n  }, [threadOpenOnThisGrid, openThread, openThreadMetadata]);\n\n  // This is just boring conversion from \"(elem) => void\" to ref object\n  // \"{current: Element}\"\n  const refSetFloating = useAsRefObject(refs.setFloating);\n\n  const cellRenderer = useCallback(\n    (params: ICellRendererParams) =>\n      CellWithThreadAndPresence(params, gridId, refs.setReference),\n    [gridId, refs.setReference],\n  );\n\n  const rowData = useMemo(() => {\n    const data: {\n      year: number;\n      'figma-valuation': string | null;\n      'notion-valuation': string | null;\n    }[] = [];\n\n    const figmaData = chartData[0].data;\n    const notionData = chartData[1].data;\n    let currentYear = 2012;\n\n    for (let i = 0; i < figmaData.length; i++) {\n      const figmaVal = figmaData[i];\n      const notionVal = notionData[i];\n\n      const gridDataRow = {\n        year: currentYear,\n        'figma-valuation': figmaVal\n          ? currencyFormatter(figmaVal * 10000)\n          : null,\n        'notion-valuation': notionVal\n          ? currencyFormatter(notionVal * 10000)\n          : null,\n      };\n\n      data.push(gridDataRow);\n      currentYear++;\n    }\n    return data;\n  }, []);\n\n  return (\n    <div\n      id=\"grid-container\"\n      className={'ag-theme-alpine'}\n      ref={gridContainerRef}\n    >\n      {threadOpenOnThisGrid && (\n        <ThreadWrapper\n          forwardRef={refSetFloating}\n          location={LOCATION}\n          threadId={openThread!}\n          metadata={openThreadMetadata}\n          style={{\n            ...floatingStyles, // to position the thread next to the pin\n            zIndex: 1, // to be above AgGrid\n            // Hide the thread if its row is scrolled out of view.\n            // Use css visibility: hidden instead of display: none to hide\n            // this thread. display: none would remove the Thread from DOM\n            // and thus would lose the draft message.\n            visibility: rowOfOpenThreadVisible ? 'visible' : 'hidden',\n          }}\n        />\n      )}\n      <AgGridReact\n        ref={gridRef}\n        getRowId={(params) => getRowId(params.data)}\n        rowData={rowData}\n        defaultColDef={{\n          cellRenderer,\n        }}\n        columnDefs={COLUMN_DEFS}\n        onGridReady={onGridReady}\n        suppressRowTransform={true}\n        suppressDragLeaveHidesColumns={true}\n        onBodyScroll={(e) => {\n          // Check if the open thread's row is scrolled out of view\n          if (threadOpenOnThisGrid) {\n            setRowOfOpenThreadVisible(\n              // NOTE: same logic is needed for columns if horizontal scrolling is allowed\n              isRowInScrollView(e.api, openThreadMetadata.rowId),\n            );\n          }\n        }}\n        onCellClicked={(e) => {\n          // On cell click, we might want to open/close/start a thread\n          if (!orgId) {\n            // appease the typechecker\n            throw new Error('org information not ready');\n          }\n\n          const rowId = getRowId(e.data);\n          const colId = e.column.getId();\n          const threadId = makeThreadId({ orgId, gridId, rowId, colId });\n          if (threadId === openThread) {\n            setOpenThread(null);\n          } else if (threads.has(threadId)) {\n            setOpenThread(threadId);\n          } else {\n            const metadata: GridThreadMetadata = {\n              type: 'grid',\n              gridId,\n              rowId,\n              colId,\n            };\n            addThread(threadId, metadata);\n            setOpenThread(threadId);\n          }\n        }}\n      ></AgGridReact>\n    </div>\n  );\n}\n\n// Custom table cell renderer with presence and thread indicator\nfunction CellWithThreadAndPresence(\n  params: ICellRendererParams,\n  gridId: string,\n  setReference: (el: Element | null) => void,\n) {\n  const { threads, openThread } = useContext(ThreadsContext)!;\n  const rowId = getRowId(params.data);\n  const colId = params.column?.getId();\n  const orgId = user.useViewerData()?.organizationID;\n  if (!colId) {\n    throw new Error('unexpected error: missing column id');\n  }\n  const threadId = orgId && makeThreadId({ orgId, gridId, colId, rowId });\n  const threadMetadata =\n    threadId !== undefined && threadId !== null\n      ? threads.get(threadId)\n      : undefined;\n\n  const location = useMemo(\n    () => ({ gridId, rowId, colId }),\n    [colId, gridId, rowId],\n  );\n\n  return (\n    <>\n      <PresenceObserver\n        location={location}\n        style={{\n          display: 'flex',\n          gap: '4px',\n          alignItems: 'center',\n          justifyContent: 'space-between',\n        }}\n      >\n        <div\n          style={{ textOverflow: 'ellipsis', overflow: 'hidden' }}\n          title={params.value}\n        >\n          {params.value}\n        </div>\n        <PresenceFacepile\n          location={location}\n          excludeViewer={false}\n          maxUsers={1}\n        />\n        {threadMetadata && threadId && (\n          <img\n            src={commentIcon}\n            ref={openThread === threadId ? setReference : undefined}\n          />\n        )}\n      </PresenceObserver>\n    </>\n  );\n}\n\nconst COLUMN_DEFS: ColDef[] = [\n  {\n    field: 'year',\n    filter: true,\n    sortable: true,\n  },\n  {\n    field: 'figma-valuation',\n    headerName: 'Figma',\n    filter: true,\n    sortable: true,\n  },\n  {\n    field: 'notion-valuation',\n    headerName: 'Notion',\n    filter: true,\n    sortable: true,\n  },\n];\n\n// helper function that converts a function style ref into a ref object\nfunction useAsRefObject(refMethod: (e: HTMLElement | null) => void) {\n  return useMemo(() => {\n    let val: HTMLElement | null = null;\n    return {\n      get current() {\n        return val;\n      },\n      set current(element: HTMLElement | null) {\n        val = element;\n        refMethod(element);\n      },\n    };\n  }, [refMethod]);\n}\n\n// Check if row with id rowId is within the scrollable view\nfunction isRowInScrollView(api: GridApi<any>, rowId: string): boolean {\n  const rowNode = api.getRowNode(rowId);\n  if (\n    !rowNode ||\n    rowNode.rowTop === null ||\n    rowNode.rowHeight === null ||\n    rowNode.rowHeight === undefined\n  ) {\n    return false;\n  }\n  const { top: visibleTop, bottom: visibleBottom } =\n    api.getVerticalPixelRange();\n  const rowTop = rowNode.rowTop;\n  const rowBottom = rowTop + rowNode.rowHeight;\n  // The row spans pixels from rowTop to rowBottom. The grid\n  // currently displays pixels from visibleTop to visibleBottom.\n  return (\n    (rowTop >= visibleTop && rowTop <= visibleBottom) ||\n    (rowBottom >= visibleTop && rowBottom <= visibleBottom)\n  );\n}\n\n// Given data of a table row, returns the row's unique ID\nfunction getRowId(data: { year: number }) {\n  return data.year.toString();\n}\n\n// Constructs a thread ID\nfunction makeThreadId({\n  orgId,\n  gridId,\n  rowId,\n  colId,\n}: {\n  orgId: string;\n  gridId: string;\n  rowId: string;\n  colId: string;\n}) {\n  return `${orgId}_${gridId}_${rowId}_${colId}`;\n}\n\n// https://blog.ag-grid.com/formatting-numbers-strings-currency-in-ag-grid/\nfunction currencyFormatter(currency: number) {\n  const sansDec = currency.toFixed(0);\n  const formatted = sansDec.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n  return '$' + `${formatted}`;\n}\n",
    'src/components/CommentIcon.svg':
      '<svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" fill="none"><path fill="#fff" fill-rule="evenodd" d="M2.572 1.893a31.028 31.028 0 0 1 9.855 0c1.078.173 1.823 1.117 1.823 2.176v3.862c0 1.06-.745 2.002-1.822 2.176a30.905 30.905 0 0 1-3.888.376.584.584 0 0 0-.396.168L5.46 13.336a.562.562 0 0 1-.96-.399v-2.582a30.835 30.835 0 0 1-1.928-.247C1.495 9.933.75 8.989.75 7.93V4.07c0-1.06.745-2.003 1.822-2.177Z" clip-rule="evenodd"/></svg>',
    'src/components/CommentsIcon.tsx':
      'export function CommentsIcon() {\n  return (\n    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none">\n      <path\n        d="M3.505 2.365A41.37 41.37 0 0 1 9 2c1.863 0 3.697.124 5.495.365 1.247.167 2.18 1.108 2.435 2.268a4.45 4.45 0 0 0-.577-.069 43.142 43.142 0 0 0-4.706 0C9.229 4.696 7.5 6.727 7.5 8.998v2.24c0 1.413.67 2.735 1.76 3.562l-2.98 2.98A.75.75 0 0 1 5 17.25v-3.443c-.501-.048-1-.106-1.495-.172C2.033 13.438 1 12.162 1 10.72V5.28c0-1.441 1.033-2.718 2.505-2.915Z"\n        fill="#fff"\n      />\n      <path\n        d="M14 6c-.762 0-1.52.02-2.271.062C10.157 6.148 9 7.472 9 8.998v2.24c0 1.519 1.147 2.839 2.71 2.935.214.013.428.024.642.034.2.009.385.09.518.224l2.35 2.35a.75.75 0 0 0 1.28-.531v-2.07c1.453-.195 2.5-1.463 2.5-2.915V8.998c0-1.526-1.157-2.85-2.729-2.936A41.64 41.64 0 0 0 14 6Z"\n        fill="#fff"\n      />\n    </svg>\n  );\n}\n',
    'src/components/Dashboard.tsx':
      "import type { MutableRefObject } from 'react';\nimport { useState, useContext, useEffect } from 'react';\nimport { PagePresence, NotificationListLauncher } from '@cord-sdk/react';\nimport type { NavigateFn } from '@cord-sdk/types';\n\nimport { ThreadsContext } from '../ThreadsContext';\nimport { HighchartsExample } from './HighchartsExample';\nimport { AGGridExample } from './AGGridExample';\nimport { ThreadedCommentsButton } from './ThreadedCommentsButton';\n\nexport const LOCATION = { page: 'dashboard-new' };\nexport const CHART_ID = 'some-unique-and-stable-id-of-this-chart';\nexport const GRID_ID = 'some-unique-and-stable-id-of-this-grid';\nfunction Dashboard({\n  navigateRef,\n  highchartsDataSeries,\n}: {\n  navigateRef: MutableRefObject<NavigateFn | null>;\n  highchartsDataSeries?: { start: number; end: number }[];\n}) {\n  const { openThread, setOpenThread, setRequestToOpenThread } =\n    useContext(ThreadsContext)!;\n\n  useEffect(() => {\n    navigateRef.current = (_url, _location, { threadID }) => {\n      // Since our app is an SPA, we don't need to actually navigate to a\n      // specific URL, but rather can just open up the indicated thread ID. We\n      // then return \"true\" to tell Cord that we have handled the navigation and\n      // it doesn't need to proceed to the actual URL navigation.\n      //\n      // Full documentation on the navigate hook is here:\n      // https://docs.cord.com/js-apis-and-hooks/initialization#navigate-3\n      setRequestToOpenThread(threadID);\n      return true;\n    };\n  }, [navigateRef, setRequestToOpenThread]);\n\n  // Effect to close open thread on ESCAPE key press and also stop thread\n  // creation mode\n  useEffect(() => {\n    const close = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        setOpenThread(null);\n      }\n    };\n    document.addEventListener('keydown', close);\n    return () => document.removeEventListener('keydown', close);\n  }, [setOpenThread]);\n\n  // Effect to close thread if user clicks anywhere but a Pin or Thread\n  useEffect(() => {\n    if (openThread) {\n      const close = (event: MouseEvent) => {\n        if (\n          !event.composedPath().some((e) => {\n            if (e instanceof Element) {\n              const elName = e.tagName.toLowerCase();\n              return elName === 'cord-pin' || elName === 'cord-thread';\n            }\n            return false;\n          })\n        ) {\n          // user clicked somewhere that's not the pin nor thread\n          setOpenThread(null);\n        }\n      };\n      document.addEventListener('mousedown', close);\n      return () => document.removeEventListener('mousedown', close);\n    }\n    return () => {};\n  }, [openThread, setOpenThread]);\n\n  const [threadListOpen, setThreadListOpen] = useState(false);\n  return (\n    <>\n      <div id=\"dashboard\">\n        <div className=\"header\">\n          <h1>Your collaborative dashboard</h1>\n          <div id=\"collaboration\">\n            <ThreadedCommentsButton\n              open={threadListOpen}\n              setOpen={setThreadListOpen}\n            />\n            <PagePresence location={LOCATION} />\n            <NotificationListLauncher\n              onClick={() => setThreadListOpen(false)}\n              // Remove this if you want all notifications from all locations\n              filter={{ location: { page: 'dashboard-new' } }}\n            />\n          </div>\n        </div>\n\n        <div className=\"grid highcharts\">\n          <div className=\"panel\">\n            <HighchartsExample\n              chartId={CHART_ID}\n              highchartsDataSeries={highchartsDataSeries}\n            />\n          </div>\n\n          <AGGridExample gridId={GRID_ID} />\n        </div>\n      </div>\n    </>\n  );\n}\n\nexport default Dashboard;\n",
    'src/components/HighchartsExample.tsx':
      "import HighchartsReact from 'highcharts-react-official';\nimport {\n  useMemo,\n  useContext,\n  useEffect,\n  useState,\n  useRef,\n  useReducer,\n  useCallback,\n} from 'react';\nimport * as Highcharts from 'highcharts';\nimport type { TooltipPositionerPointObject } from 'highcharts';\nimport cx from 'classnames';\nimport { user } from '@cord-sdk/react';\nimport chartData from '../chartData.json';\nimport type { ChartThreadMetadata } from '../ThreadsContext';\nimport { ThreadsContext } from '../ThreadsContext';\nimport { LOCATION } from './Dashboard';\nimport { ThreadWrapper } from './ThreadWrapper';\nimport commentIcon from './CommentIcon.svg';\n\nconst DATE_RANGE_SELECTOR_OPTIONS = [\n  { start: 2012, end: 2017 },\n  { start: 2018, end: 2022 },\n];\n\nconst Y_AXIS_MIDWAY_POINT = 150;\n\nconst COMMENT_ICON_HEIGHT_PX = 15;\nconst COMMENT_ICON_TOP_OFFSET_PX = 3;\nconst GAP_PX = 8;\n\ntype HighChartsData = { start: number; end: number };\n\ntype Props = {\n  chartId: string;\n  highchartsDataSeries?: HighChartsData[];\n};\nexport function HighchartsExample({ chartId, highchartsDataSeries }: Props) {\n  const chartRef = useRef<HighchartsReact.RefObject>(null);\n  const {\n    setOpenThread,\n    threads,\n    requestToOpenThread,\n    setRequestToOpenThread,\n  } = useContext(ThreadsContext)!;\n\n  // If we pass in a specific range we use it otherwise default to the DATE_RANGE_SELECTOR_OPTIONS\n  const [dateRanges, _setDateRanges] = useState<HighChartsData[]>(\n    highchartsDataSeries ?? DATE_RANGE_SELECTOR_OPTIONS,\n  );\n  const [selectedDateRange, setSelectedDateRange] = useState(dateRanges[0]);\n\n  // Effect to update chart's axis range when selectedDateRange changes\n  useEffect(() => {\n    chartRef.current?.chart.xAxis[0].setExtremes(\n      selectedDateRange.start,\n      selectedDateRange.end,\n    );\n  }, [selectedDateRange]);\n\n  const chartParentRef = useRef<HTMLDivElement>(null);\n  // Effect to update chart so that the requested thread can be displayed\n  useEffect(() => {\n    if (requestToOpenThread === null) {\n      return;\n    }\n\n    const metadata = threads.get(requestToOpenThread);\n    if (metadata?.type !== 'chart' || metadata.chartId !== chartId) {\n      // request is not for this chart\n      return;\n    }\n\n    // Make the requested chart series visible\n    const series = chartRef.current?.chart.get(metadata.seriesId) as\n      | Highcharts.Series\n      | undefined;\n    if (!series) {\n      throw new Error('series not found');\n    }\n    series.setVisible(true);\n\n    // Adjust the range of the chart axes\n    const rangeForThread = dateRanges.find(\n      (range) => range.start <= metadata.x && metadata.x <= range.end,\n    );\n    if (!rangeForThread) {\n      throw new Error(`thread ${requestToOpenThread} cannot be displayed`);\n    }\n    setSelectedDateRange(rangeForThread);\n    // NOTE: Eagerly update the chart axis range, so that the thread we are\n    // going to open does not auto-close because the axis range does not\n    // match\n    chartRef.current?.chart.xAxis[0].setExtremes(\n      rangeForThread.start,\n      rangeForThread.end,\n    );\n\n    // Scroll the page to the chart and open the thread\n    chartParentRef.current?.scrollIntoView({\n      behavior: 'smooth',\n      block: 'center',\n    });\n    setRequestToOpenThread(null);\n    // Open the thread with a small delay. Opening the thread immediately\n    // currently stops the scrollIntoView().\n    setTimeout(() => setOpenThread(requestToOpenThread), 300);\n  }, [\n    chartId,\n    threads,\n    requestToOpenThread,\n    setOpenThread,\n    setRequestToOpenThread,\n    dateRanges,\n  ]);\n\n  // A dummy reducer with the sole purpose to re-render this component.\n  // Used to to redraw positions of pins when chart redraws\n  const [_, forceRerender] = useReducer((x) => x + 1, 0);\n  const chartOptions = useChartOptions(chartId, chartRef, forceRerender);\n\n  return (\n    <>\n      <div className=\"chart-header\">\n        <h2 className=\"chart-title\">Market cap of collaborative companies*</h2>\n        <p className=\"footnote\">*Valuation data extremely inaccurate</p>\n      </div>\n      <div className=\"date-range-selector\">\n        {dateRanges.length > 1 &&\n          dateRanges.map(({ start, end }) => {\n            return (\n              <button\n                key={`${start}-${end}`}\n                className={cx('date-range-selector-option', {\n                  'date-range-selector-option-active':\n                    selectedDateRange.start === start &&\n                    selectedDateRange.end === end,\n                })}\n                onClick={() => setSelectedDateRange({ start, end })}\n                type=\"button\"\n              >\n                {start} - {end}\n              </button>\n            );\n          })}\n      </div>\n      <div ref={chartParentRef} style={{ position: 'relative' }}>\n        <HighchartsReact\n          ref={chartRef}\n          highcharts={Highcharts}\n          options={chartOptions}\n        />\n        {chartRef.current?.chart && (\n          <ChartThreads\n            selectedDateRange={selectedDateRange}\n            chartId={chartId}\n            chart={chartRef.current.chart}\n          />\n        )}\n      </div>\n    </>\n  );\n}\n\nfunction useChartOptions(\n  chartId: string,\n  chartRef: React.RefObject<HighchartsReact.RefObject>,\n  onRedraw: (() => void) | undefined,\n) {\n  const orgId = user.useViewerData()?.organizationID;\n  const { threads, addThread, setOpenThread, openThread } =\n    useContext(ThreadsContext)!;\n\n  // To enable us to highlight the background of the point in plotBands below\n  const activeThreadXPoint = useMemo(() => {\n    if (!openThread) {\n      return null;\n    }\n\n    const thread = threads.get(openThread);\n    if (!thread || thread.type === 'grid') {\n      return null;\n    }\n\n    return thread.x;\n  }, [openThread, threads]);\n  const maybeAddComment = useCallback(() => {\n    const hoverPoint = chartRef.current?.chart.hoverPoint;\n    if (!hoverPoint) {\n      return;\n    }\n    if (!orgId) {\n      throw new Error('org information not ready');\n    }\n\n    const metadata = {\n      type: 'chart',\n      chartId,\n      seriesId: hoverPoint.series.userOptions.id!,\n      x: hoverPoint.x,\n      y: hoverPoint.y!,\n    } as const;\n    // NOTE: Allow only one thread per point by using the point x,y in threadId\n    // NOTE: Use orgId as part of thread Id to have unique ids across orgs\n    const threadId = `${orgId}_${metadata.chartId}_${metadata.seriesId}_${metadata.x}_${metadata.y}`;\n    addThread(threadId, metadata);\n    setOpenThread(threadId);\n  }, [addThread, chartId, chartRef, orgId, setOpenThread]);\n\n  return useMemo(\n    () => ({\n      plotOptions: {\n        series: {\n          lineWidth: 5,\n          cursor: 'pointer',\n          events: {\n            click: maybeAddComment,\n          },\n          label: {\n            connectorAllowed: false,\n          },\n          pointStart: 2012,\n          marker: {\n            radius: 6,\n            symbol: 'circle',\n          },\n        },\n        column: {\n          pointPadding: 0.2,\n          borderWidth: 0,\n          pointWidth: 22,\n          borderRadius: 4,\n        },\n      },\n\n      chart: {\n        type: 'line',\n        style: {\n          fontFamily:\n            'Roboto, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Oxygen, Ubuntu, Cantarell, \"Fira Sans\", \"Droid Sans\", \"Helvetica Neue\", sans-serif',\n          cursor: 'pointer',\n        },\n        backgroundColor: '#3D3A33',\n        events: {\n          redraw: onRedraw,\n          click: maybeAddComment,\n        },\n      },\n\n      series: chartData,\n\n      // Standard options from here on\n      title: {\n        text: null,\n      },\n\n      yAxis: {\n        title: {\n          text: 'Valuation in USD billions',\n        },\n        gridLineColor: 'transparent',\n        labels: {\n          style: {\n            color: '#edeff1',\n            fontSize: '12px',\n          },\n        },\n      },\n\n      xAxis: {\n        min: 2012,\n        max: 2022,\n        accessibility: {\n          rangeDescription: 'Range: 2012 to 2022',\n        },\n        categories: [\n          '2012',\n          '2013',\n          '2014',\n          '2015',\n          '2016',\n          '2017',\n          '2018',\n          '2019',\n          '2020',\n          '2021',\n          '2022',\n        ],\n        crosshair: { color: '#2e2e2e' },\n        tickInterval: 1,\n        labels: {\n          style: {\n            color: '#edeff1',\n            fontSize: '12px',\n          },\n        },\n        // Highlights the background of the thread that is currently opened\n        plotBands: [\n          {\n            color: '#2e2e2e',\n            from: activeThreadXPoint ? activeThreadXPoint - 0.5 : null, // Start of the plot band\n            to: activeThreadXPoint ? activeThreadXPoint + 0.5 : null, // End of the plot band\n          },\n        ],\n      },\n\n      legend: {\n        layout: 'horizontal',\n        align: 'right',\n        verticalAlign: 'bottom',\n        itemStyle: {\n          color: '#edeff1',\n          fontSize: '14px',\n        },\n        itemHoverStyle: {\n          color: '#97979f',\n        },\n        symbolWidth: 24,\n      },\n\n      tooltip: {\n        // Always show tooltip below the bar\n        positioner: function (\n          _labelHeight: number,\n          _labelWidth: number,\n          point: TooltipPositionerPointObject,\n        ) {\n          return {\n            x: point.plotX,\n            y: point.plotY + 20,\n          };\n        },\n        borderRadius: 12,\n        padding: 12,\n        borderColor: 'transparent',\n        backgroundColor: '#000000',\n        outside: true,\n        style: {\n          color: '#edeff1',\n        },\n        formatter: function (): string | false {\n          const { x, y, color, series } = this as any;\n          if (activeThreadXPoint === x) {\n            return false;\n          }\n          const commentCTA = 'Click to comment';\n          return `\n                <div style=\"display: flex; flex-direction: column; gap: 8px\">\n                  <div><b>${x}</b></div>\n\n                  <div style=\"display: flex; align-items: center; gap: 4px\">\n                    <span style=\"color: ${color};\">●</span>\n                    ${series.name}: <b>${y}</b>\n                  </div>\n                  <div style=\"display: flex; align-items: center; gap: 4px\">\n                    <div style=\"width: 15px; height: 15px;\">\n                      <img src=${commentIcon}  />\n                    </div>\n                    <span>${commentCTA}</span>\n                  </div>\n                </div>\n        `;\n        },\n        useHTML: true,\n      },\n    }),\n    [activeThreadXPoint, maybeAddComment, onRedraw],\n  );\n}\n\ntype ChartThreadsProps = {\n  chartId: ChartThreadMetadata['chartId'];\n  chart: Highcharts.Chart;\n  selectedDateRange: HighChartsData;\n};\n\nfunction ChartThreads({\n  chartId,\n  chart,\n  selectedDateRange,\n}: ChartThreadsProps) {\n  const { threads } = useContext(ThreadsContext)!;\n  return (\n    <>\n      {Array.from(threads)\n        .filter((keyVal): keyVal is [string, ChartThreadMetadata] => {\n          const [_threadId, metadata] = keyVal;\n          return metadata.type === 'chart' && metadata.chartId === chartId;\n        })\n        .map(([threadId, metadata]) => (\n          <ChartThread\n            key={threadId}\n            threadId={threadId}\n            metadata={metadata}\n            chart={chart}\n            selectedDateRange={selectedDateRange}\n          />\n        ))}\n    </>\n  );\n}\n\ntype ChartThreadProps = {\n  threadId: string;\n  metadata: ChartThreadMetadata;\n  chart: Highcharts.Chart;\n  selectedDateRange: HighChartsData;\n};\n\nfunction ChartThread({\n  threadId,\n  metadata,\n  chart,\n  selectedDateRange,\n}: ChartThreadProps) {\n  const { openThread, setOpenThread } = useContext(ThreadsContext)!;\n  const isVisible = isPointVisible(chart, metadata);\n  const isOpen = openThread === threadId;\n\n  // Effect to close thread if it becomes not visible\n  useEffect(() => {\n    if (!isVisible && isOpen) {\n      setOpenThread(null);\n    }\n  }, [isOpen, isVisible, openThread, setOpenThread, threadId]);\n  const series = chart.get(metadata.seriesId) as Highcharts.Series & {\n    pointXOffset: number;\n  };\n\n  const pointPixelPosX = series.xAxis.toPixels(metadata.x, false);\n  const pointPixelPosY = series.yAxis.toPixels(metadata.y, false);\n\n  useEffect(() => {\n    // To make the thread opened on initial load\n    // NOTE: If more than one thread has `metadata.autogenerated`,\n    // only the last one rendered will be open. (Only one thread can\n    // be open at a time)\n    if (metadata.autogenerated) {\n      setOpenThread(threadId);\n    }\n  }, [metadata.autogenerated, setOpenThread, threadId]);\n\n  // We want to make sure the thread is visible within the bounds of the graph\n  // We take the mid point of the x and y axis to determine where to place the thread\n  // If the comment is placed below the midpoint of the x axis, we position the\n  // thread with the 'left' css property otherwise we use the 'right' property.\n  // If the comment is placed below the midpoint of the y axis, we position the\n  // thread with the 'top' css property otherwise we use the 'bottom' property.\n  const threadPosition: Partial<React.CSSProperties> = useMemo(() => {\n    const midwayXDataRage =\n      (selectedDateRange.end + selectedDateRange.start) / 2;\n    const positionLeft = metadata.x < midwayXDataRage;\n    const positionTop = metadata.y > Y_AXIS_MIDWAY_POINT;\n    return {\n      left: positionLeft\n        ? `calc(100% + ${COMMENT_ICON_HEIGHT_PX}px)`\n        : undefined,\n      right: !positionLeft\n        ? `calc(100% + ${COMMENT_ICON_HEIGHT_PX}px)`\n        : undefined,\n      top: positionTop ? -COMMENT_ICON_HEIGHT_PX : undefined,\n      bottom: !positionTop ? -COMMENT_ICON_HEIGHT_PX : undefined,\n    };\n  }, [metadata.x, metadata.y, selectedDateRange]);\n\n  return (\n    <div\n      style={{\n        position: 'absolute',\n        // When not visible, position all the way to the left, to not\n        // add unnecessary horizontal scroll.\n        left: isVisible ? pointPixelPosX + GAP_PX - COMMENT_ICON_HEIGHT_PX : 0,\n        // When the commented bar is visible, show the comment icon\n        // on top of it.\n        top: isVisible\n          ? `calc(${\n              pointPixelPosY -\n              COMMENT_ICON_HEIGHT_PX -\n              GAP_PX -\n              COMMENT_ICON_TOP_OFFSET_PX\n            }px`\n          : 0,\n        transition: 'top 0.5s, left 0.5s',\n        visibility: isVisible ? 'visible' : 'hidden',\n        zIndex: isOpen ? 5 : 0, // The highcharts tooltip has a z-index of 3\n      }}\n    >\n      <img\n        key={threadId}\n        src={commentIcon}\n        onClick={() => setOpenThread(isOpen ? null : threadId)}\n        style={{ height: COMMENT_ICON_HEIGHT_PX }}\n      />\n\n      <ThreadWrapper\n        location={LOCATION}\n        threadId={threadId}\n        metadata={metadata}\n        style={{\n          position: 'absolute',\n          ...threadPosition,\n        }}\n      />\n    </div>\n  );\n}\n\n// Check if the point that the thread's metadata is associated with is\n// currently visible\nfunction isPointVisible(\n  chart: Highcharts.Chart,\n  metadata: ChartThreadMetadata,\n): boolean {\n  const series = chart.get(metadata.seriesId) as Highcharts.Series | undefined;\n  if (!series || !series.visible) {\n    return false;\n  }\n  const point = series.points.find(\n    (p) => p.x === metadata.x && p.y === metadata.y,\n  );\n  if (!point) {\n    return false;\n  }\n  const { min: xMin, max: xMax } = chart.xAxis[0].getExtremes();\n  // NOTE: the check of the yAxis range is not really necessary for this app\n  const { min: yMin, max: yMax } = chart.yAxis[0].getExtremes();\n  return (\n    xMin <= metadata.x &&\n    yMin <= metadata.y &&\n    metadata.x <= xMax &&\n    metadata.y <= yMax\n  );\n}\n",
    'src/components/ThreadWrapper.tsx':
      "import { Thread } from '@cord-sdk/react';\nimport type { FlatJsonObject } from '@cord-sdk/types';\nimport { useState, useEffect, useContext } from 'react';\nimport type { ThreadMetadata } from '../ThreadsContext';\nimport { ThreadsContext } from '../ThreadsContext';\n\ntype ThreadWrapperProps = {\n  forwardRef?: React.RefObject<HTMLElement | null>;\n  location: FlatJsonObject;\n  threadId: string;\n  metadata: ThreadMetadata;\n  style?: React.CSSProperties;\n};\n\n// A wrapper over cord-thread that removes itself if empty when closed\nexport function ThreadWrapper({\n  forwardRef,\n  location,\n  threadId,\n  metadata,\n  style,\n}: ThreadWrapperProps) {\n  const { openThread, removeThread, setOpenThread } =\n    useContext(ThreadsContext)!;\n  const [numberOfMessages, setNumberOfMessages] = useState<number | undefined>(\n    undefined,\n  );\n  // Effect that removes this thread if it has no messages at the time it is closed\n  useEffect(() => {\n    const isOpen = threadId === openThread;\n    if (!isOpen && numberOfMessages !== undefined && numberOfMessages <= 0) {\n      removeThread(threadId);\n    }\n\n    return () => {\n      if (numberOfMessages !== undefined && numberOfMessages <= 0) {\n        removeThread(threadId);\n      }\n    };\n  }, [numberOfMessages, openThread, removeThread, threadId]);\n\n  return (\n    <Thread\n      forwardRef={forwardRef}\n      location={location}\n      threadId={threadId}\n      metadata={metadata}\n      autofocus={openThread === threadId}\n      style={{\n        // Using css visibility: hidden instead of display: none to hide this\n        // thread if it is not the open one. display: none would remove the\n        // Thread from DOM and thus would lose the draft message.\n        visibility: openThread === threadId ? 'visible' : 'hidden',\n        width: '300px',\n        maxHeight: '300px',\n        ...style,\n      }}\n      onThreadInfoChange={(info) => setNumberOfMessages(info.messageCount)}\n      onClose={() => setOpenThread(null)}\n    />\n  );\n}\n",
    'src/components/ThreadedCommentsButton.tsx':
      "import { useCallback, useContext } from 'react';\nimport { ThreadedComments } from '@cord-sdk/react';\nimport { autoUpdate, flip, shift, useFloating } from '@floating-ui/react';\nimport { ThreadsContext } from '../ThreadsContext';\nimport { LOCATION } from './Dashboard';\nimport { CommentsIcon } from './CommentsIcon';\n\ntype Props = {\n  open: boolean;\n  setOpen: (f: (v: boolean) => boolean) => void;\n};\nexport function ThreadedCommentsButton({ open, setOpen }: Props) {\n  const { openThread, setRequestToOpenThread } = useContext(ThreadsContext)!;\n\n  const { refs, floatingStyles } = useFloating({\n    whileElementsMounted: autoUpdate,\n    placement: 'bottom',\n    transform: false,\n    middleware: [\n      shift({\n        padding: 2,\n      }),\n      flip(),\n    ],\n  });\n\n  const toggleThreadedComments = useCallback(() => {\n    setOpen((prev) => !prev);\n  }, [setOpen]);\n\n  const handleClickMessage = useCallback(\n    ({ threadId }: { threadId: string | null; messageId: string | null }) => {\n      setRequestToOpenThread(threadId);\n    },\n    [setRequestToOpenThread],\n  );\n\n  return (\n    <>\n      <button\n        className=\"action-button\"\n        style={open ? { backgroundColor: '#6a6b6c' } : undefined}\n        ref={refs.setReference}\n        onClick={toggleThreadedComments}\n        type=\"button\"\n      >\n        <CommentsIcon />\n        All comments\n      </button>\n      {open && (\n        <div\n          className=\"threadlist-container\"\n          ref={refs.setFloating}\n          style={floatingStyles}\n        >\n          <ThreadedComments\n            location={LOCATION}\n            onMessageClick={handleClickMessage}\n            composerPosition=\"none\"\n            highlightThreadId={openThread ?? undefined}\n          />\n        </div>\n      )}\n    </>\n  );\n}\n",
    'src/css/aggrid.css':
      '.ag-theme-alpine {\n  --ag-font-size: 17px;\n  --ag-font-family: monospace;\n\n  --ag-foreground-color: var(--white);\n  --ag-background-color: var(--black);\n\n  --ag-header-foreground-color: var(--white);\n  --ag-header-background-color: var(--grey-dark);\n  --ag-header-column-resize-handle-color: var(--white);\n\n  --ag-border-color: var(--grey-light);\n  --ag-secondary-border-color: var(--grey-light);\n\n  --ag-odd-row-background-color: var(--black);\n}\n\n.ag-header-cell {\n  border-right: 1px solid var(--grey-light);\n  cursor: auto;\n}\n.ag-cell {\n  border-right: 1px solid var(--grey-light) !important;\n}\n\n.ag-root-wrapper {\n  cursor: pointer;\n  border-radius: 8px;\n}\n\ncord-presence-facepile.cord-component {\n  margin-left: auto;\n}\n',
    'src/css/highcharts.css':
      '.date-range-selector {\n  align-items: center;\n  display: flex;\n  gap: 8px;\n  padding: 4px 0px 8px;\n  margin-bottom: 20px;\n  width: fit-content;\n}\n\n.date-range-selector-option {\n  background-color: var(--black);\n  border-radius: 4px;\n  border: 0;\n  color: var(--white);\n  cursor: pointer;\n  font-family: inherit;\n  font-size: 16px;\n  padding: 4px 8px;\n}\n\n.date-range-selector-option:hover {\n  background-color: var(--purple);\n}\n\n.date-range-selector-option-active {\n  background-color: var(--purple);\n  color: white;\n  cursor: default;\n}\n\n.date-range-selector-option-active:hover {\n  background-color: var(--purple);\n}\n',
    'src/css/index.css':
      "@import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap');\n\n:root {\n  --purple: #9a6aff;\n  --purple-dark: #442f71;\n  --orange: #fa7351;\n  --grey-x-light: #97979f;\n  --grey-light: #6a6b6c;\n  --grey-dark: #3d3a33;\n  --grey-x-dark: #1d1f24;\n  --black: #121314;\n  --white: #edeff1;\n  --pink: #e95b94;\n\n  --cord-color-base: var(--grey-x-dark);\n  --cord-color-base-strong: #f6f6f620;\n  --cord-color-base-x-strong: var(--grey-light);\n  --cord-color-content-emphasis: var(--white);\n  --cord-color-content-primary: var(--white);\n  --cord-color-content-secondary: var(--grey-light);\n  --cord-color-notification: var(--pink);\n  --cord-primary-button-background-color: var(--purple);\n  --cord-secondary-button-content-color: var(--white);\n  --cord-tertiary-button-content-color: var(--white);\n  --cord-color-brand-primary: var(--white);\n\n  /* Drop shadow large */\n  box-shadow: 0px 2px 16px 0px rgba(0, 0, 0, 0.16);\n}\n\n*,\n*::before,\n*::after {\n  box-sizing: border-box;\n}\n\n* {\n  margin: 0;\n}\n\nbody {\n  background: var(--black);\n  margin: 0;\n  padding: 0;\n  padding-top: 73px;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n    sans-serif;\n}\n\n.cord-component a {\n  color: var(--purple);\n}\n\n#dashboard {\n  font-family: Roboto, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI',\n    Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\n  color: var(--white);\n  max-width: 1200px;\n  margin: auto;\n}\n\n#dashboard .header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding-bottom: 32px;\n}\n\n#dashboard h1 {\n  line-height: 64px;\n  font-weight: 300;\n  font-size: 24px;\n  margin: 0;\n  padding: 0;\n}\n\n#dashboard h2 {\n  font-weight: 400;\n  font-size: 20px;\n  line-height: 32px;\n  margin: 0;\n  padding: 0;\n}\n\n#dashboard .panel {\n  background: var(--grey-dark);\n  padding: 40px 64px;\n  box-shadow: 0px 2px 4px 0px rgba(0, 0, 0, 0.08);\n  border-radius: 8px;\n}\n\n#dashboard .panel.highcharts {\n  display: flex;\n  flex-direction: column;\n  gap: 20px;\n}\n\n#dashboard .panel .chart-header {\n  margin-bottom: 8px;\n}\n\n#dashboard .grid {\n  display: grid;\n  grid-gap: 40px;\n}\n\n#collaboration {\n  display: flex;\n  align-items: center;\n  gap: 12px;\n  z-index: 1; /* prevents pins from overlaying the dashboard header */\n}\n\n.ag-theme-alpine {\n  --ag-value-change-value-highlight-background-color: #e37400;\n  font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Oxygen',\n    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n    sans-serif;\n}\n\n#grid-container {\n  height: 400px;\n}\n\n.cell {\n  position: relative;\n}\n\n/* when cell is selected, make border of .cell-with-thread smaller */\n.ag-theme-alpine\n  .ag-ltr\n  .ag-cell-focus:not(.ag-cell-range-selected):focus-within\n  .cell-with-thread {\n  border-width: 1px;\n}\n\n/* we don't want gaps between cells */\n.ag-theme-alpine .ag-ltr .ag-cell {\n  border: none;\n}\n\n.action-button,\n.cord-button[data-cord-button='open-notification-list'] {\n  cursor: pointer;\n  max-width: 100%;\n  text-align: center;\n  align-items: center;\n  display: flex;\n  justify-content: center;\n  position: relative;\n  font-size: 14px;\n  font-family: inherit;\n  line-height: 20px;\n  border-style: none;\n  text-transform: none;\n  border-radius: var(--cord-border-radius-medium, var(--cord-space-3xs, 4px));\n  padding: 10px;\n  color: var(--white);\n  background-color: var(--grey-dark);\n  gap: var(--cord-floating-threads-gap, var(--cord-space-3xs, 4px));\n}\n\n.action-button:hover,\n.cord-button[data-cord-button='open-notification-list']:hover {\n  color: var(--white);\n  background-color: var(--grey-light);\n}\n\n.action-button:active {\n  background-color: var(--grey-light);\n}\n\n.threadlist-container {\n  width: 300px;\n  background: var(--white);\n  margin-top: 6px;\n  border-radius: 4px;\n  z-index: 9;\n  box-shadow: var(\n    --cord-shadow-large,\n    0 var(--cord-space-4xs, 2px) var(--cord-space-m, 16px) 0 rgba(0, 0, 0, 0.16)\n  );\n}\n\n.cord-component .cord-avatar-container {\n  border-radius: 50%;\n}\n\ncord-threaded-comments {\n  max-height: 400px;\n}\n\ncord-notification-list-launcher .cord-button-label {\n  font-size: 14px;\n}\n\ncord-notification-list-launcher\n  .cord-button[data-cord-button='open-notification-list']\n  .cord-icon\n  path:first-of-type {\n  fill: var(--white);\n}\n\ncord-page-presence.cord-component .cord-avatar-container {\n  width: 36px;\n  height: 36px;\n  border-radius: 50%;\n}\n\n.cord-badge::after {\n  color: var(--white);\n}\n\ncord-thread.cord-component {\n  border-radius: 8px;\n}\n\n.cord-message .cord-timestamp {\n  display: none;\n}\n\n.footnote {\n  font-size: 12px;\n  color: var(--grey-x-light);\n  margin: 0;\n}\n",
    'src/css/threads-toggle.css':
      '/* Taken from https://www.w3schools.com/howto/howto_css_switch.asp */\n\n/* The switch - the box around the slider */\n.switch {\n  position: relative;\n  display: inline-block;\n  width: 60px;\n  height: 34px;\n  flex-shrink: 0;\n}\n\n/* Hide default HTML checkbox */\n.switch input {\n  opacity: 0;\n  width: 0;\n  height: 0;\n}\n\n/* The slider */\n.slider {\n  position: absolute;\n  cursor: pointer;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: #ccc;\n  -webkit-transition: .4s;\n  transition: .4s;\n}\n\n.slider:before {\n  position: absolute;\n  content: "";\n  height: 26px;\n  width: 26px;\n  left: 4px;\n  bottom: 4px;\n  background-color: white;\n  -webkit-transition: .4s;\n  transition: .4s;\n}\n\ninput:checked + .slider {\n  background-color: #1a73e8;\n}\n\ninput:focus + .slider {\n  box-shadow: 0 0 1px #1a73e8;\n}\n\ninput:checked + .slider:before {\n  -webkit-transform: translateX(26px);\n  -ms-transform: translateX(26px);\n  transform: translateX(26px);\n}\n\n/* Rounded sliders */\n.slider.round {\n  border-radius: 34px;\n}\n\n.slider.round:before {\n  border-radius: 50%;\n}\n\n.switch-label {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  font-weight: 300;\n  font-size: 14px;\n  gap: 4px;\n\n}\n',
    'src/main.tsx':
      "import * as ReactDOM from 'react-dom/client';\nimport App from './App';\nimport './css/index.css';\nimport './css/highcharts.css';\nimport './css/aggrid.css';\nimport './css/threads-toggle.css';\n\nReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(\n  <App />,\n);\n",
    'src/utils.ts':
      "import { useEffect, useState } from 'react';\n\nconst CORD_TOKEN_LOCALSTORAGE_KEY = 'cord_token';\nconst CORD_SAMPLE_TOKEN_ENDPOINT = 'https://api.cord.com/sample-token';\n\nconst ONE_MINUTE_MS = 60 * 1000;\nconst ONE_DAY_MS = ONE_MINUTE_MS * 60 * 24;\nconst SEVEN_DAYS_MS = ONE_DAY_MS * 7;\n\nfunction canUseLocalStorage() {\n  try {\n    typeof window.localStorage;\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function useCordSampleToken_DEMO_ONLY_NOT_FOR_PRODUCTION() {\n  const [{ value: cordAuthToken, hasExpired }, setCordAuthToken] = useState<{\n    value: string | null;\n    hasExpired: boolean;\n  }>(\n    canUseLocalStorage()\n      ? () => getLocalStorageItemWithExpiry(CORD_TOKEN_LOCALSTORAGE_KEY)\n      : { value: null, hasExpired: true },\n  );\n\n  useEffect(() => {\n    if (!cordAuthToken || hasExpired) {\n      void fetchCordSampleToken().then((token) => {\n        if (token) {\n          setCordAuthToken({ value: token, hasExpired: false });\n\n          if (canUseLocalStorage()) {\n            localStorage.setItem(\n              CORD_TOKEN_LOCALSTORAGE_KEY,\n              withExpiry(\n                token,\n                // Sample token expires after 7 days\n                getTimeInXMillisecondsFromNow(SEVEN_DAYS_MS),\n              ),\n            );\n          } else {\n            console.warn(\n              `Cannot save Cord token in the localStorage. If you refresh the page, you will lose all your messages.`,\n            );\n          }\n        }\n      });\n    }\n  }, [cordAuthToken, hasExpired]);\n\n  return cordAuthToken;\n}\n\nasync function fetchCordSampleToken(): Promise<string | null> {\n  try {\n    const response = await fetch(CORD_SAMPLE_TOKEN_ENDPOINT, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ extended: 'true' }),\n    });\n\n    if (response.status !== 200) {\n      throw new Error('Failed to fetch Cord sample token');\n    }\n\n    const { client_auth_token } = await response.json();\n    return client_auth_token;\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction getLocalStorageItemWithExpiry(key: string) {\n  const itemStr = localStorage.getItem(key);\n  if (!itemStr) {\n    return { value: null, hasExpired: true };\n  }\n\n  try {\n    const item = JSON.parse(itemStr);\n    const isValid = Boolean(item.expiry && item.value);\n    if (!isValid) {\n      localStorage.removeItem(key);\n      return { value: null, hasExpired: true };\n    }\n\n    const hasExpired = new Date().getTime() > item.expiry;\n    return { value: item.value, hasExpired };\n  } catch {\n    localStorage.removeItem(key);\n    return { value: null, hasExpired: true };\n  }\n}\n\nexport function withExpiry(value: string, expiry: number) {\n  const item = {\n    value: value,\n    expiry,\n  };\n\n  return JSON.stringify(item);\n}\n\nfunction getTimeInXMillisecondsFromNow(xMilliseconds: number) {\n  return new Date(new Date().getTime() + xMilliseconds).getTime();\n}\n",
    'tsconfig.json':
      '{\n  "compilerOptions": {\n    "target": "ESNext",\n    "useDefineForClassFields": true,\n    "lib": ["DOM", "DOM.Iterable", "ESNext"],\n    "allowJs": false,\n    "skipLibCheck": true,\n    "esModuleInterop": false,\n    "allowSyntheticDefaultImports": true,\n    "strict": true,\n    "forceConsistentCasingInFileNames": true,\n    "module": "ESNext",\n    "moduleResolution": "Node",\n    "resolveJsonModule": true,\n    "isolatedModules": true,\n    "noEmit": true,\n    "jsx": "react-jsx"\n  },\n  "include": ["src"],\n  "references": [{ "path": "./tsconfig.node.json" }]\n}\n',
  },
  'video-player': {
    'index.html':
      '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/src/images/favicon.png" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Cord Sample App - Video player</title>\n  </head>\n  <body>\n    <div id="root"></div>\n    <script type="module" src="/src/main.tsx"></script>\n  </body>\n</html>\n',
    'package.json':
      '{\n  "name": "cord-sample-video-player",\n  "private": true,\n  "version": "1.0.0",\n  "type": "module",\n  "scripts": {\n    "dev": "vite",\n    "build": "tsc && vite build",\n    "preview": "vite preview"\n  },\n  "dependencies": {\n    "@cord-sdk/react": "^1.15.1",\n    "react": "^18.2.0",\n    "react-dom": "^18.2.0",\n    "react-syntax-highlighter": "^15.5.0"\n  },\n  "devDependencies": {\n    "@cord-sdk/types": "^1.15.1",\n    "@types/react": "^18.2.18",\n    "@types/react-dom": "^18.0.6",\n    "@types/react-syntax-highlighter": "^15.5.5",\n    "@vitejs/plugin-react": "^2.0.1",\n    "typescript": "~5.1.6",\n    "vite": "^3.0.7"\n  }\n}\n',
    'src/App.tsx':
      "import { CordProvider } from '@cord-sdk/react';\n\n\nimport { useCordSampleToken_DEMO_ONLY_NOT_FOR_PRODUCTION } from './utils';\nimport { VideoPlayer } from './components/VideoPlayer';\n\nexport default function App() {\n  const authToken = useCordSampleToken_DEMO_ONLY_NOT_FOR_PRODUCTION();\n  return (\n    // All the Cord React components must be children of a single CordProvider component.\n    <CordProvider clientAuthToken={authToken}>\n      \n      {authToken && (\n        <VideoPlayer\n          video={\n            'https://cdn.cord.com/cord-website-video/cord-website-video-with-subs-1080p.mp4'\n          }\n        />\n      )}\n    </CordProvider>\n  );\n}\n",
    'src/ThreadsContext.tsx':
      "import type { PropsWithChildren } from 'react';\nimport {\n  createContext,\n  useCallback,\n  useEffect,\n  useState,\n  useMemo,\n} from 'react';\nimport { thread } from '@cord-sdk/react';\nimport type { Location } from '@cord-sdk/types';\n\nexport type ThreadMetadata = {\n  xPercent: number;\n  yPercent: number;\n  timestamp: number;\n  autogenerated?: boolean;\n  initallyOpen?: boolean;\n  durationOnVideo?: number;\n};\n\n// Context for storing all thread related information\ntype ThreadsContextType = {\n  // Map of all threads on current page, mapping from thread's ID to its\n  // metadata\n  threads: ReadonlyMap<\n    string,\n    { metadata: ThreadMetadata; totalMessages: number }\n  >;\n  // Adds a thread to the threads map\n  addThread: (\n    threadId: string,\n    metadata: ThreadMetadata,\n    totalMessages: number,\n  ) => void;\n  // Removes a thread from the threads map\n  removeThread: (threadId: string) => void;\n\n  // The id of the thread open on this page (or null if none is open)\n  openThread: string | null;\n  setOpenThread: (arg: string | null) => void;\n};\nexport const ThreadsContext = createContext<ThreadsContextType | undefined>(\n  undefined,\n);\n\nexport function ThreadsProvider({\n  children,\n  location,\n}: PropsWithChildren<{ location: Location }>) {\n  const [threads, setThreads] = useState<\n    Map<string, { metadata: ThreadMetadata; totalMessages: number }>\n  >(new Map());\n  const addThread = useCallback(\n    (threadId: string, metadata: ThreadMetadata, totalMessages: number) =>\n      setThreads((oldThreads) => {\n        if (\n          oldThreads.has(threadId) &&\n          oldThreads.get(threadId)?.totalMessages === totalMessages\n        ) {\n          return oldThreads;\n        }\n        const newThreads = new Map(oldThreads);\n        newThreads.set(threadId, { metadata, totalMessages });\n        return newThreads;\n      }),\n    [],\n  );\n  const removeThread = useCallback(\n    (threadId: string) =>\n      setThreads((oldThreads) => {\n        if (!oldThreads.has(threadId)) {\n          return oldThreads;\n        }\n        const newThreads = new Map(oldThreads);\n        newThreads.delete(threadId);\n        return newThreads;\n      }),\n    [],\n  );\n\n  // Fetch existing threads associated with location\n  const {\n    threads: threadSummaries,\n    hasMore,\n    loading,\n    fetchMore,\n  } = thread.useLocationData(location, { includeResolved: false });\n  useEffect(() => {\n    if (loading) {\n      return;\n    }\n    if (hasMore) {\n      // NOTE: For this demo, fetch all threads on the page.\n      void fetchMore(1000);\n    }\n    threadSummaries\n      .filter((t) => t.total > 0 && Object.keys(t.metadata).length > 0)\n      .forEach((t) => addThread(t.id, t.metadata as ThreadMetadata, t.total));\n  }, [addThread, fetchMore, hasMore, loading, threadSummaries, threads]);\n\n  const [openThread, setOpenThread] = useState<string | null>(null);\n\n  const context = useMemo(\n    () => ({\n      threads,\n      addThread,\n      removeThread,\n      openThread,\n      setOpenThread,\n    }),\n    [threads, addThread, removeThread, openThread],\n  );\n  return (\n    <ThreadsContext.Provider value={context}>\n      {children}\n    </ThreadsContext.Provider>\n  );\n}\n",
    'src/components/CustomControls.tsx':
      'import { useRef, useCallback, useState } from \'react\';\nimport cx from \'classnames\';\n\nconst ICON_SIZE = 24;\n\nexport function CustomControls({\n  duration,\n  currentTime,\n  isPlaying,\n  muted,\n  onPause,\n  onPlay,\n  onSeek,\n  onToggleMute,\n}: {\n  duration: number;\n  currentTime: number;\n  isPlaying: boolean;\n  muted: boolean;\n  onPlay: () => Promise<void> | undefined;\n  onPause: () => void;\n  onSeek: (newTime: number) => void;\n  onToggleMute: () => void;\n}) {\n  // Local state so that dragging the thumb has 0 delay.\n  const [seekXCoord, setSeekXCoord] = useState<number | null>(null);\n  const progressRef = useRef<HTMLDivElement | null>(null);\n\n  const handleTogglePlaying = useCallback(() => {\n    if (isPlaying) {\n      onPause?.();\n    } else {\n      void onPlay?.();\n    }\n  }, [isPlaying, onPause, onPlay]);\n\n  const getTimeAtCursor = useCallback(\n    (cursorX: number) => {\n      if (!progressRef.current) {\n        return 0;\n      }\n\n      const { width, left, right } =\n        progressRef.current.getBoundingClientRect();\n      const safeCursorX = Math.min(Math.max(cursorX, left), right);\n      return ((safeCursorX - left) / width) * duration;\n    },\n    [duration],\n  );\n\n  const handleSeek = useCallback(\n    (e: React.MouseEvent<HTMLElement> | MouseEvent) =>\n      onSeek(getTimeAtCursor(e.clientX)),\n    [getTimeAtCursor, onSeek],\n  );\n\n  const handleMouseMove = useCallback(\n    (e: MouseEvent) => {\n      setSeekXCoord(e.clientX);\n      handleSeek(e);\n    },\n    [handleSeek],\n  );\n\n  const handleStopSeeking = useCallback(() => {\n    setSeekXCoord(null);\n    window.removeEventListener(\'mousemove\', handleMouseMove);\n    window.removeEventListener(\'mouseup\', handleStopSeeking);\n  }, [handleMouseMove]);\n\n  const handleStartSeeking = useCallback(() => {\n    window.addEventListener(\'mousemove\', handleMouseMove);\n    window.addEventListener(\'mouseup\', handleStopSeeking);\n  }, [handleMouseMove, handleStopSeeking]);\n\n  const getProgressBarWidth = useCallback(() => {\n    const time =\n      seekXCoord !== null ? getTimeAtCursor(seekXCoord) : currentTime;\n    return duration > 0 ? `${(time / duration) * 100}%` : 0;\n  }, [currentTime, duration, getTimeAtCursor, seekXCoord]);\n\n  return (\n    <div className="custom-controls-container">\n      <div className="custom-controls">\n        <PlayButton\n          isPlaying={isPlaying}\n          handleTogglePlaying={handleTogglePlaying}\n        />\n        <span>{secondsToFormattedTimestamp(currentTime)}</span>\n        <span className="duration">\n          {!Number.isNaN(duration) &&\n            \' / \' + secondsToFormattedTimestamp(duration)}\n        </span>\n        <MuteButton muted={muted} onToggleMute={onToggleMute} />\n      </div>\n      <div\n        className={cx(\'timeline-container\', {\n          [\'seeking\']: seekXCoord !== null,\n        })}\n        onClick={handleSeek}\n        onMouseDown={handleStartSeeking}\n        ref={progressRef}\n      >\n        <div className="progress-bar-background" />\n        <div\n          className="progress-bar-foreground"\n          style={{\n            width: getProgressBarWidth(),\n          }}\n        />\n      </div>\n    </div>\n  );\n}\n\n/**\n * Converts an amount of seconds to `hh:mm:ss` format.\n * @example\n * secondsToFormattedTimestamp(2061); // "34:21"\n */\nexport function secondsToFormattedTimestamp(durationSeconds: number) {\n  const hrs = Math.floor(durationSeconds / 3600);\n  const mins = Math.floor((durationSeconds % 3600) / 60);\n  const secs = Math.floor(durationSeconds) % 60;\n\n  let timestamp = \'\';\n  if (hrs > 0) {\n    timestamp += \'\' + hrs + \':\' + (mins < 10 ? \'0\' : \'\');\n  }\n  timestamp += \'\' + mins + \':\' + (secs < 10 ? \'0\' : \'\');\n  timestamp += \'\' + secs;\n  return timestamp;\n}\n\nfunction PlayButton({\n  isPlaying,\n  handleTogglePlaying,\n}: {\n  isPlaying: boolean;\n  handleTogglePlaying: () => void;\n}) {\n  return (\n    <svg\n      className="play-pause-btn"\n      xmlns="http://www.w3.org/2000/svg"\n      fill="currentColor"\n      viewBox="0 0 24 24"\n      strokeWidth={1.5}\n      stroke="currentColor"\n      height={ICON_SIZE}\n      width={ICON_SIZE}\n      onClick={handleTogglePlaying}\n    >\n      {isPlaying ? (\n        <path\n          strokeLinecap="round"\n          strokeLinejoin="round"\n          d="M15.75 5.25v13.5m-7.5-13.5v13.5"\n        />\n      ) : (\n        <path\n          strokeLinecap="round"\n          strokeLinejoin="round"\n          d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z"\n        />\n      )}\n    </svg>\n  );\n}\n\nfunction MuteButton({\n  muted,\n  onToggleMute,\n}: {\n  muted: boolean;\n  onToggleMute: () => void;\n}) {\n  return (\n    <svg\n      xmlns="http://www.w3.org/2000/svg"\n      className="mute-btn"\n      fill="white"\n      width={ICON_SIZE}\n      height={ICON_SIZE}\n      viewBox="0 0 24 24"\n      strokeWidth={1.5}\n      stroke="currentColor"\n      onClick={onToggleMute}\n    >\n      {muted ? (\n        <path\n          strokeLinecap="round"\n          strokeLinejoin="round"\n          d="M17.25 9.75L19.5 12m0 0l2.25 2.25M19.5 12l2.25-2.25M19.5 12l-2.25 2.25m-10.5-6l4.72-4.72a.75.75 0 011.28.531V19.94a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.506-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.395C2.806 8.757 3.63 8.25 4.51 8.25H6.75z"\n        />\n      ) : (\n        <path\n          strokeLinecap="round"\n          strokeLinejoin="round"\n          d="M19.114 5.636a9 9 0 010 12.728M16.463 8.288a5.25 5.25 0 010 7.424M6.75 8.25l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75z"\n        />\n      )}\n    </svg>\n  );\n}\n',
    'src/components/VideoPin.tsx':
      "import { useContext, useState, useCallback, useMemo, useEffect } from 'react';\nimport { thread, Pin, Thread } from '@cord-sdk/react';\nimport type { Location } from '@cord-sdk/types';\nimport cx from 'classnames';\nimport type { ThreadMetadata } from '../ThreadsContext';\nimport { ThreadsContext } from '../ThreadsContext';\n\n// Control how long should a pin stay on the video, before\n// moving back to the controls.\nconst PIN_TIME_ON_VIDEO_SECONDS = 3;\n\n/**\n * A Pin which is either: over the video, exactly where the comment was added,\n * or on the controls, again matching the timestamp of the comment.\n * When the video plays, and the timestamp approaches a Pin, the Pin\n * gets moved over the video. After a fixed amount of time (PIN_TIME_ON_VIDEO),\n * the Pin will move back to the controls.\n */\nexport function VideoPin({\n  id,\n  metadata,\n  location,\n  currentTime,\n  duration,\n}: {\n  id: string;\n  metadata: ThreadMetadata;\n  location: Location;\n  currentTime: number;\n  duration: number;\n}) {\n  const { threads, removeThread, openThread, setOpenThread } =\n    useContext(ThreadsContext)!;\n\n  // When hovering on a Pin on the controls, we show a preview of the first\n  // message of that thread.\n  const [showThreadPreviewBubble, setThreadShowPreviewBubble] = useState(false);\n\n  // Whether the pin should be displayed on the controls, as opposed to\n  // on the video itself.\n  const displayOnControls = useCallback(\n    (threadMetadata: ThreadMetadata) => {\n      return (\n        Math.abs(threadMetadata.timestamp - currentTime) >\n          PIN_TIME_ON_VIDEO_SECONDS / 2 && openThread !== id\n      );\n    },\n    [currentTime, openThread, id],\n  );\n\n  // Usually, we'll keep a pin on screen for a fixed, short amount of time.\n  // But some Pins we want to keep around for longer.\n  // NOTE: This code exists just to support some cool interactions on Cord.com's demos.\n  const isPersistingPin = useMemo(() => {\n    // Special case for threads with extra metadata\n    return (\n      metadata.autogenerated &&\n      metadata.durationOnVideo &&\n      Math.floor(currentTime) >= metadata.timestamp &&\n      Math.floor(currentTime) <= metadata.timestamp + metadata.durationOnVideo\n    );\n  }, [\n    currentTime,\n    metadata.autogenerated,\n    metadata.durationOnVideo,\n    metadata.timestamp,\n  ]);\n\n  const onPinClick = useCallback(() => {\n    const isOpenThreadEmpty =\n      openThread && threads.get(openThread)?.totalMessages === 0;\n\n    if (isOpenThreadEmpty) {\n      removeThread(openThread);\n    }\n\n    // Clicking on the openThread's pin will close the thread.\n    if (openThread === id) {\n      setOpenThread(null);\n      return;\n    }\n\n    setOpenThread(id);\n    const video = document.querySelector('video');\n\n    if (!(video instanceof HTMLVideoElement)) {\n      return;\n    }\n\n    // Want to pause the video without moving the video frame when a user\n    // clicks on a pin that is on the video\n    if (displayOnControls(metadata) && !isPersistingPin) {\n      video.currentTime = metadata.timestamp;\n    }\n    video.pause();\n  }, [\n    openThread,\n    threads,\n    id,\n    setOpenThread,\n    displayOnControls,\n    metadata,\n    isPersistingPin,\n    removeThread,\n  ]);\n\n  // The position of the Pins on the video are controlled by these\n  // CSS variables.\n  const getPinCSSVariables = useCallback(\n    (threadMetadata: ThreadMetadata): React.CSSProperties | undefined => {\n      if (!duration) {\n        return undefined;\n      }\n      return {\n        '--pin-x-percent': `${threadMetadata.xPercent}%`,\n        '--pin-y-percent': `${threadMetadata.yPercent}%`,\n        '--pin-time-ratio': `${threadMetadata.timestamp / duration}`,\n      } as React.CSSProperties;\n    },\n    [duration],\n  );\n\n  /**\n   * NOTE: useThreadData creates a thread if one doesn't already exists.\n   * For this reason, we are passing the same `location` to it.\n   * Failing to do so might result in the thread being created at the\n   * default location (the current window URL)\n   */\n  const { firstMessage } = thread.useThreadData(id, { location });\n\n  // Special code to make the thread auto open based on timestamp\n  // NOTE: This code exists just to support some cool interactions on Cord.com's demos.\n  useEffect(() => {\n    if (!metadata.initallyOpen) {\n      return;\n    }\n    if (metadata.timestamp === currentTime) {\n      setOpenThread(id);\n    }\n  }, [\n    currentTime,\n    id,\n    metadata.initallyOpen,\n    metadata.timestamp,\n    setOpenThread,\n  ]);\n\n  // The classname determines where the pin will be rendered.\n  const pinClassname = useMemo(() => {\n    // Some staged threads we want to extend the pin time on the video\n    if (isPersistingPin && openThread !== id) {\n      return 'pin-on-video-pulse';\n    }\n\n    if (displayOnControls(metadata)) {\n      return 'pin-on-control';\n    }\n\n    // Some staged threads we want to add a pulse animation to\n    if (metadata.autogenerated && !metadata.initallyOpen && openThread !== id) {\n      return 'pin-on-video-pulse';\n    }\n\n    return 'pin-on-video';\n  }, [displayOnControls, id, isPersistingPin, metadata, openThread]);\n\n  return (\n    <Pin\n      location={location}\n      threadId={id}\n      style={getPinCSSVariables(metadata)}\n      className={cx(\n        pinClassname,\n        // Position thread based on which half of the video the pin sits in\n        { ['thread-on-the-left']: metadata.xPercent > 50 },\n        { ['thread-on-the-top']: metadata.yPercent > 50 },\n      )}\n      onClick={onPinClick}\n      onMouseEnter={() => setThreadShowPreviewBubble(true)}\n      onMouseLeave={() => setThreadShowPreviewBubble(false)}\n    >\n      {showThreadPreviewBubble &&\n        displayOnControls(metadata) &&\n        firstMessage?.plaintext && (\n          <div className=\"thread-preview-bubble-container\">\n            <p className=\"thread-preview-bubble\">{firstMessage.plaintext}</p>\n          </div>\n        )}\n      <Thread\n        threadId={id}\n        metadata={metadata}\n        location={location}\n        onResolved={() => removeThread(id)}\n        showPlaceholder={false}\n        autofocus={openThread === id}\n        style={{\n          display: openThread === id ? 'block' : 'none',\n        }}\n      />\n    </Pin>\n  );\n}\n",
    'src/components/VideoPlayer.tsx':
      "import { useCallback, useContext, useEffect, useRef, useState } from 'react';\nimport {\n  ThreadedComments,\n  PagePresence,\n  NotificationListLauncher,\n} from '@cord-sdk/react';\nimport type { Location, MessageInfo, Point2D } from '@cord-sdk/types';\nimport { ThreadsProvider, ThreadsContext } from '../ThreadsContext';\nimport { CustomControls } from './CustomControls';\nimport { useAddTimestamp } from './useAddTimestamp';\nimport { VideoPin } from './VideoPin';\n\nconst LOCATION = { page: 'video' };\n\nexport function VideoPlayer({ video }: { video: string }) {\n  return (\n    <ThreadsProvider location={LOCATION}>\n      <CommentableVideo video={video} location={LOCATION} />\n    </ThreadsProvider>\n  );\n}\n\n/**\n * A clickable video, which will record the position and timestamp of the click.\n */\nfunction CommentableVideo({\n  video,\n  location,\n}: {\n  video: string;\n  location: Location;\n}) {\n  const { threads, addThread, removeThread, setOpenThread, openThread } =\n    useContext(ThreadsContext)!;\n  const videoRef = useRef<HTMLVideoElement | null>(null);\n  // Keeping video related state in our components State to trigger re-renders.\n  const [currentTime, setCurrentTime] = useState(0);\n  const [duration, setDuration] = useState(0);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [isVideoMuted, setIsVideoMuted] = useState(false);\n  // Add a tooltip following the cursor when hovering on the video.\n  const [cursorTooltipPosition, setCursorTooltipPosition] =\n    useState<Point2D | null>(null);\n  const [cursorTooltipText, setCursorTooltipText] = useState<\n    'Click to comment' | 'Click to resume'\n  >(isPlaying ? 'Click to comment' : 'Click to resume');\n\n  // When users add a new comment, we'll add the current timestamp\n  // to their message.\n  useAddTimestamp();\n\n  const handleCloseThread = useCallback(() => {\n    if (!openThread) {\n      return;\n    }\n\n    if (threads.get(openThread)?.totalMessages === 0) {\n      removeThread(openThread);\n    }\n    setOpenThread(null);\n  }, [openThread, removeThread, setOpenThread, threads]);\n\n  const onVideoClick = useCallback(\n    (e: React.MouseEvent<HTMLVideoElement>) => {\n      if (!videoRef.current) {\n        return;\n      }\n      if (!(e.target instanceof HTMLVideoElement)) {\n        return;\n      }\n\n      // Toggle the video play/pause, just like you'd expect\n      if (videoRef.current.paused) {\n        void videoRef.current.play();\n      } else {\n        videoRef.current.pause();\n      }\n\n      // We either close the currently open thread..\n      if (openThread) {\n        handleCloseThread();\n        return;\n      }\n      // ..Or create a new thread!\n      e.preventDefault();\n      const rect = e.target.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const y = e.clientY - rect.top;\n      const timestamp = videoRef.current.currentTime;\n      const threadID = `video-thread-${x}-${y}-${timestamp}`;\n      addThread(\n        threadID,\n        {\n          // We store a percentage of where the user has clicked,\n          // so we can show the Pin in the right spot no matter\n          // what are the dimensions of the video.\n          xPercent: (x / rect.width) * 100,\n          yPercent: (y / rect.height) * 100,\n          timestamp,\n        },\n        0,\n      );\n      setOpenThread(threadID);\n    },\n    [videoRef, openThread, addThread, setOpenThread, handleCloseThread],\n  );\n\n  // This is a browser native callback. I.e. the browser will call this when\n  //  the time of the video is updated.\n  // We update our internal state, which triggers a re-render and e.g.\n  // updates our CustomControls bar.\n  const onVideoTimeUpdate = useCallback(() => {\n    if (!videoRef.current) {\n      return;\n    }\n    setCurrentTime(videoRef.current.currentTime);\n    setDuration(videoRef.current.duration);\n  }, [videoRef]);\n  // OnPlay/Pause are also browser native callbacks.\n  const onVideoPlay = useCallback(() => {\n    setIsPlaying(true);\n    setCursorTooltipText('Click to comment');\n    handleCloseThread();\n  }, [handleCloseThread]);\n  const onVideoPause = useCallback(() => {\n    setIsPlaying(false);\n    setCursorTooltipText('Click to resume');\n  }, []);\n\n  // Let's connect ThreadedComments to the video! Clicking on\n  // a message in ThreadedComment will move the video time to\n  // the timestamp of that message, and open the thread.\n  const onMessageClick = useCallback(\n    (mi: MessageInfo) => {\n      if (!videoRef.current) {\n        return;\n      }\n      const threadMetadata = threads.get(mi.threadId)?.metadata;\n      if (!threadMetadata) {\n        console.log(`Thread ${mi.threadId} not found`);\n        return;\n      }\n\n      videoRef.current.currentTime = threadMetadata.timestamp;\n      videoRef.current.pause();\n      window.scroll({ top: 0, behavior: 'smooth' });\n      setOpenThread(mi.threadId);\n    },\n    [videoRef, setOpenThread, threads],\n  );\n\n  // Close open thread when users press ESCAPE\n  const handlePressEscape = useCallback(\n    (e: KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        handleCloseThread();\n      }\n    },\n    [handleCloseThread],\n  );\n  useEffect(() => {\n    document.addEventListener('keydown', handlePressEscape);\n    return () => document.removeEventListener('keydown', handlePressEscape);\n  }, [handlePressEscape]);\n\n  // When hovering on the video, we want to show the cursor tooltip.\n  const handleMouseMoveOnCommentableElement = useCallback(\n    ({ clientX: x, clientY: y }: React.MouseEvent<HTMLVideoElement>) => {\n      setCursorTooltipPosition({ x, y });\n    },\n    [],\n  );\n  const handleLeaveCommentableElement = useCallback(\n    () => setCursorTooltipPosition(null),\n    [],\n  );\n\n  // Changes the time of the video. E.g. updateCurrentTime(0) makes\n  // the video start from the beginning.\n  const updateCurrentTime = useCallback(\n    (newTimeSeconds: number) => {\n      if (!videoRef.current) {\n        return;\n      }\n      videoRef.current.currentTime = newTimeSeconds;\n    },\n    [videoRef],\n  );\n\n  return (\n    <>\n      <div id=\"video-player-demo-container\">\n        <div id=\"top-bar\">\n          <PagePresence location={location} />\n          <NotificationListLauncher label=\"Notifications\" />\n        </div>\n        <div id=\"content\">\n          {/* Used to catch clicks outside the thread, and close it. */}\n          <div\n            className=\"thread-underlay\"\n            style={{\n              display: openThread !== null ? 'block' : 'none',\n            }}\n            onClick={handleCloseThread}\n          />\n          <div id=\"commentableVideo\">\n            <div id=\"videoWrapper\">\n              <video\n                ref={videoRef}\n                disablePictureInPicture\n                controlsList=\"nofullscreen\"\n                onClick={onVideoClick}\n                onTimeUpdate={onVideoTimeUpdate}\n                onCanPlay={() => onVideoTimeUpdate()}\n                src={video}\n                muted={isVideoMuted}\n                onMouseMove={handleMouseMoveOnCommentableElement}\n                onMouseLeave={handleLeaveCommentableElement}\n                onPause={onVideoPause}\n                onPlay={onVideoPlay}\n              ></video>\n              <CustomControls\n                duration={duration}\n                currentTime={currentTime}\n                isPlaying={isPlaying}\n                muted={isVideoMuted}\n                onPlay={() => videoRef.current?.play()}\n                onPause={() => videoRef.current?.pause()}\n                onToggleMute={() => setIsVideoMuted((prev) => !prev)}\n                onSeek={updateCurrentTime}\n              />\n              {Array.from(threads).map(([key, { metadata }]) => {\n                return (\n                  <VideoPin\n                    key={key}\n                    id={key}\n                    location={location}\n                    metadata={metadata}\n                    currentTime={currentTime}\n                    duration={duration}\n                  />\n                );\n              })}\n            </div>\n          </div>\n          <ThreadedComments\n            location={location}\n            composerPosition=\"none\"\n            messageOrder=\"newest_on_top\"\n            onMessageClick={onMessageClick}\n            highlightThreadId={openThread ?? undefined}\n          />\n        </div>\n      </div>\n      {cursorTooltipPosition && (\n        <div\n          className=\"cursor-tooltip\"\n          style={{\n            left: `calc(16px + ${cursorTooltipPosition.x}px)`,\n            top: `calc(20px + ${cursorTooltipPosition.y}px)`,\n          }}\n        >\n          {cursorTooltipText}\n        </div>\n      )}\n    </>\n  );\n}\n",
    'src/components/useAddTimestamp.ts':
      "import { useContext, useEffect } from 'react';\nimport { ThreadsContext } from '../ThreadsContext';\nimport { secondsToFormattedTimestamp } from './CustomControls';\n\n/** Add a timestamp to the beginning of the message when users add a comment. */\nexport function useAddTimestamp() {\n  const { threads } = useContext(ThreadsContext)!;\n\n  useEffect(() => {\n    const cordSDK = window?.CordSDK;\n    if (!cordSDK) {\n      return;\n    }\n\n    cordSDK.updateOptions({\n      beforeMessageCreate: (message, context) => {\n        // We want to add the timestamp only to the first message\n        if (!context.firstMessage) {\n          return message;\n        }\n\n        const metadata = threads.get(context.threadID)?.metadata;\n        if (!metadata) {\n          return message;\n        }\n\n        const timestamp = secondsToFormattedTimestamp(metadata.timestamp);\n        const firstContentBlock = message.content[0] as {\n          type: string;\n          children: object[];\n        };\n        if (firstContentBlock.type === 'p') {\n          const newBlock = {\n            type: 'p',\n            children: [\n              { text: `[${timestamp}] `, class: 'timestamp' },\n              ...firstContentBlock['children'],\n            ],\n          };\n          message.content[0] = newBlock;\n        }\n        return message;\n      },\n    });\n  }, [threads]);\n}\n",
    'src/css/index.css':
      "@import url('https://fonts.googleapis.com/css2?family=Roboto&family=Roboto+Mono&display=swap');\n\n*,\n*::before,\n*::after {\n  box-sizing: border-box;\n}\n\n* {\n  padding: 0;\n  margin: 0;\n}\n\nhtml {\n  --black: #121314;\n  --grey-dark: #2e2e2e;\n  --grey-light: #97979f;\n  --white: #fff;\n  --purple-dark: #442f71;\n  --purple: #9a6aff;\n\n  --yellow-dark: #e9e469;\n  --pink: #e95b94;\n  height: 100%;\n  --scrollbar-thumb: #504f4f;\n  --video-border-radius: 32px;\n  --threaded-comments-width: 280px;\n  --pin-scale-up: 1.1765;\n  --commentable-video-width: calc(100% - 400px);\n}\n\nbody {\n  background: var(--yellow-dark);\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n    sans-serif;\n  height: auto;\n}\n\n.cord-component a {\n  color: var(--purple);\n}\n\n/* Style scrollbar like MacOS. Only works in WebKit-based and Blink broswers \n(e.g Chrome, Safari, Opera but not Firefox */\n.cord-threaded-comments-thread-list::-webkit-scrollbar {\n  background-color: transparent;\n  width: 16px;\n}\n\n.cord-threaded-comments-thread-list::-webkit-scrollbar-track {\n  background-color: transparent;\n}\n\n.cord-threaded-comments-thread-list::-webkit-scrollbar-thumb {\n  background-color: var(--scrollbar-thumb);\n  border-radius: 16px;\n  border: 5px solid #2e2e2e;\n}\n\n/* Hide buttons at the top and bottom of the scrollbar */\n.scrollbar::-webkit-scrollbar-button {\n  display: none;\n}\n\n#root {\n  --header-height: 56px;\n  margin-top: calc(var(--header-height) + 32px);\n}\n\n#top-bar {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n\n  width: calc(var(--commentable-video-width) + var(--threaded-comments-width));\n  margin: 0 auto;\n}\n\n#content {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  max-height: 800px;\n}\n\n.custom-controls-container {\n  position: absolute;\n  bottom: 0;\n  color: white;\n  width: 100%;\n  display: flex;\n  flex-direction: column;\n  padding: 0 16px;\n  /* Users can drag to seek the video. This prevents \n     users from selecting e.g. the elapsed time */\n  user-select: none;\n  font-family: Roboto, sans-serif;\n\n  --timeline-height: 4px;\n\n  /* Same as the browser native controls */\n  background: linear-gradient(to bottom, var(--gradient-steps)) repeat-x bottom;\n  --gradient-steps: hsla(0, 0%, 0%, 0) 0%, hsla(0, 0%, 0%, 0.013) 8.1%,\n    hsla(0, 0%, 0%, 0.049) 15.5%, hsla(0, 0%, 0%, 0.104) 22.5%,\n    hsla(0, 0%, 0%, 0.175) 29%, hsla(0, 0%, 0%, 0.259) 35.3%,\n    hsla(0, 0%, 0%, 0.352) 41.2%, hsla(0, 0%, 0%, 0.45) 47.1%,\n    hsla(0, 0%, 0%, 0.55) 52.9%, hsla(0, 0%, 0%, 0.648) 58.8%,\n    hsla(0, 0%, 0%, 0.741) 64.7%, hsla(0, 0%, 0%, 0.825) 71%,\n    hsla(0, 0%, 0%, 0.896) 77.5%, hsla(0, 0%, 0%, 0.951) 84.5%,\n    hsla(0, 0%, 0%, 0.987) 91.9%, hsl(0, 0%, 0%) 100%;\n}\n\n.custom-controls {\n  display: flex;\n  align-items: center;\n  width: 100%;\n  height: 48px;\n}\n\n.custom-controls .play-pause-btn {\n  margin-right: 8px;\n}\n\n.custom-controls .mute-btn {\n  margin-left: auto;\n}\n\n.custom-controls .duration {\n  margin-left: 4px;\n}\n\n.custom-controls-container .progress-bar-background {\n  width: 100%;\n  height: var(--timeline-height);\n  background: var(--grey-light);\n  border-radius: 2px;\n}\n\n.custom-controls-container .progress-bar-foreground {\n  height: var(--timeline-height);\n  background-color: var(--white);\n  border-radius: 2px;\n  /* Make it overlap with the background */\n  transform: translateY(-100%);\n}\n\n.timeline-container .progress-bar-foreground::after {\n  --thumb-size: 12px;\n  content: '';\n  width: var(--thumb-size);\n  height: var(--thumb-size);\n  background: var(--white);\n  border-radius: 50%;\n  top: -4px;\n  left: calc(100% - calc(var(--thumb-size) / 2));\n  position: absolute;\n  opacity: 0;\n  transition: opacity 200ms;\n}\n\n.timeline-container:is(:hover, .seeking) .progress-bar-foreground::after {\n  opacity: 1;\n}\n\n.timeline-container {\n  /* Padding bottom Makes it easier to click it */\n  padding-bottom: 20px;\n}\n\n#video-player-demo-container {\n  display: flex;\n  margin: auto;\n  max-width: 1400px;\n  min-width: 768px;\n  padding: 16px;\n  padding-right: 5px;\n  flex-direction: column;\n  gap: 16px;\n}\n\n#commentableVideo {\n  display: flex;\n  width: var(--commentable-video-width);\n  background: var(--black);\n  border-radius: var(--video-border-radius);\n  align-self: stretch;\n  box-shadow: 0px 2px 20px 0px rgba(0, 0, 0, 0.16);\n}\n\n#videoWrapper {\n  position: relative;\n  align-self: center;\n}\n\nvideo {\n  height: 100%;\n  width: 100%;\n  object-fit: fill;\n  /* The data url below is generated by taking the contents of images/cursor.svg and turning it into\n  a Base 64 encoded data url.  I did that with the following site: https://fffuel.co/eeencode/ */\n  cursor: url('data:image/svg+xml;base64, PHN2ZyB3aWR0aD0iMzciIGhlaWdodD0iNDEiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsdGVyPSJ1cmwoI2EpIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCI+PHBhdGggZD0iTTEyLjExIDM0LjIyMyA0LjYwNiA2LjIxbDI3LjY2MiAxNC4zNy0xMy40OTYgMy42MTYtLjIzLjI5NC02LjQzIDkuNzMyWiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Im03LjYgOS43MjQgNS4yNTUgMTkuNjA4IDQuMzQtNi41NDYuMjQxLS4zMjYgOS42NDktMi41N0w3LjYgOS43MjRaIiBmaWxsPSIjOUE2QUZGIi8+PC9nPjxkZWZzPjxmaWx0ZXIgaWQ9ImEiIHg9Ii42MDUiIHk9IjQuMjExIiB3aWR0aD0iMzUuNjYyIiBoZWlnaHQ9IjM2LjAxMiIgZmlsdGVyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiPjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+PGZlQ29sb3JNYXRyaXggaW49IlNvdXJjZUFscGhhIiB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDEyNyAwIiByZXN1bHQ9ImhhcmRBbHBoYSIvPjxmZU9mZnNldCBkeT0iMiIvPjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjIiLz48ZmVDb2xvck1hdHJpeCB2YWx1ZXM9IjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMiAwIi8+PGZlQmxlbmQgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3VsdD0iZWZmZWN0MV9kcm9wU2hhZG93XzE2MTdfNjkwODkiLz48ZmVCbGVuZCBpbj0iU291cmNlR3JhcGhpYyIgaW4yPSJlZmZlY3QxX2Ryb3BTaGFkb3dfMTYxN182OTA4OSIgcmVzdWx0PSJzaGFwZSIvPjwvZmlsdGVyPjwvZGVmcz48L3N2Zz4=')\n      5 7,\n    auto;\n}\n\n.thread-underlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.pin-on-video {\n  animation: moveToVideo 0.33s;\n  bottom: calc(100% - var(--pin-y-percent));\n  left: var(--pin-x-percent);\n}\n\n.pin-on-control {\n  animation: moveToControl 0.33s;\n  bottom: 26px;\n  left: calc((100% - 32px) * var(--pin-time-ratio) + 16px - 2px);\n}\n\n.pin-on-control .cord-pin-container .cord-annotation-pin {\n  display: none;\n}\n\n.pin-on-control .cord-avatar-container {\n  border-radius: 50%;\n  border: 2px solid var(--black);\n  height: 24px;\n  width: 24px;\n}\n\n.cord-component .cord-avatar-container {\n  border-radius: 50%;\n  height: auto;\n}\n\n@keyframes moveToVideo {\n  from {\n    left: calc((100% - 32px) * var(--pin-time-ratio) + 16px - 2px);\n    bottom: 22px;\n  }\n  to {\n    left: var(--pin-x-percent);\n    bottom: calc(100% - var(--pin-y-percent));\n  }\n}\n\n@keyframes moveToControl {\n  from {\n    left: var(--pin-x-percent);\n    bottom: calc(100% - var(--pin-y-percent));\n  }\n  to {\n    left: calc((100% - 32px) * var(--pin-time-ratio) + 16px - 2px);\n    bottom: 22px;\n  }\n}\n\n.cursor-tooltip {\n  font-size: 12px;\n  font-weight: 500;\n  line-height: 16px;\n  position: fixed;\n  padding: 4px 8px 5px 8px;\n  border-radius: 2px 11px 11px 11px;\n  background: var(--purple);\n  color: var(--white);\n}\n\n.timestamp {\n  font-weight: bold;\n}\n\n/* Cord components  */\n#video-player-demo-container {\n  --cord-color-base: var(--black);\n  --cord-color-base-strong: rgba(var(--grey-light), 0.2);\n  --cord-color-content-emphasis: var(--white);\n  --cord-color-content-primary: var(--white);\n  --cord-color-notification: var(--pink);\n  --cord-secondary-button-content-color: var(--white);\n  --cord-tertiary-button-content-color: var(--white);\n  --cord-color-brand-primary: var(--white);\n}\n\n.cord-annotation-pin {\n  /* Remove annotation pin border */\n  --cord-color-content-secondary: transparent;\n}\n\n#video-player-demo-container .cord-threaded-comments {\n  border: 0;\n  border-radius: 32px;\n  padding: 16px;\n  padding-right: 8px;\n  box-shadow: 0px 2px 20px 0px rgba(0, 0, 0, 0.16);\n  min-height: 624px;\n  max-height: 624px;\n  align-self: stretch;\n  /* Put it above the underlay */\n  isolation: isolate;\n\n  width: var(--threaded-comments-width);\n}\n\n.cord-threaded-comments-thread {\n  margin-right: 6px;\n}\n\n.cord-threaded-comments-thread.cord-highlighted,\n.cord-threaded-comments-thread:hover,\n.cord-threaded-comments-thread:hover .cord-message {\n  background-color: var(--grey-dark);\n  border-radius: 16px;\n}\n\n#video-player-demo-container .cord-threaded-comments-thread-list {\n  gap: 24px;\n  /* // Scrollbar styling for Firefox */\n  scrollbar-color: var(--scrollbar-thumb) transparent;\n  scrollbar-width: thin;\n}\n\n.cord-threaded-comments .cord-expand-replies {\n  color: var(--grey-light);\n}\n\n#videoWrapper cord-pin {\n  position: absolute;\n}\n\ncord-pin,\n.cord-pin-container .cord-avatar-container,\n.timeline-container,\n.play-pause-btn,\n.mute-btn,\n.cord-threaded-comments-thread {\n  cursor: pointer;\n}\n\n#commentableVideo .cord-composer {\n  border-radius: 8px;\n}\n\n.cord-component .cord-composer:focus-within {\n  box-shadow: unset;\n}\n\n.cord-component .cord-composer {\n  background-color: var(--black);\n}\n\n#video-player-demo-container .cord-tooltip {\n  background: var(--black);\n  color: var(--white);\n}\n\n.cord-send-button.cord-disabled {\n  opacity: 0.5;\n}\n\n.cord-send-button:not(.cord-disabled):hover {\n  background-color: var(--yellow-dark);\n}\n\n.cord-composer-primary-buttons .cord-close-button:hover {\n  background-color: var(--grey-light);\n}\n\n:is(.cord-threaded-comments, cord-thread)\n  .cord-message-options-buttons\n  .cord-button:hover {\n  background-color: var(--grey-light);\n}\n\n#video-player-demo-container cord-thread {\n  border: none;\n  box-shadow: 0px 2px 16px 0px var(--black);\n  width: 250px;\n}\n\ncord-pin .cord-pin-container {\n  transition: transform 0.2s;\n}\n\ncord-pin .cord-pin-container:hover {\n  /* To get to 40x40 from starting size of 34px */\n  transform: scale(var(--pin-scale-up));\n  transform-origin: bottom left;\n}\n\ncord-pin cord-thread {\n  border-radius: 2px;\n  left: calc(100% + 8px);\n  position: absolute;\n  top: 0;\n  z-index: 1;\n}\n\ncord-thread .cord-timestamp {\n  display: none;\n}\n\ncord-pin.thread-on-the-left cord-thread {\n  left: calc(-250px - 8px);\n}\ncord-pin.thread-on-the-top cord-thread {\n  top: calc(100%);\n  transform: translateY(-100%);\n}\n\ncord-pin .thread-preview-bubble {\n  -webkit-box-orient: vertical;\n  -webkit-line-clamp: 2;\n  display: -webkit-box;\n  font-size: 12px;\n  line-height: 16px;\n  max-width: 160px;\n  margin: 0;\n  overflow: hidden;\n  width: max-content;\n}\n\ncord-pin .thread-preview-bubble-container {\n  background-color: var(--white);\n  border-radius: 4px;\n  padding: 8px;\n  position: absolute;\n  --pin-half-width: 12px;\n  /* 2px to align preview to left of Pin\n   4px gap between preview and top of Pin */\n  transform: translate(\n    calc(-1 * calc(var(--pin-half-width) + 2px)),\n    calc(-100% - calc(var(--pin-half-width) + 4px))\n  );\n}\n/* Don't make video timeline disappear */\nvideo::-webkit-media-controls-panel,\nvideo::-webkit-media-controls-timeline {\n  opacity: 1 !important;\n}\n\n.cord-component .cord-reaction-list .cord-from-viewer {\n  background-color: var(--grey-light);\n}\n\n.cord-component .cord-reaction-list {\n  background-color: var(--grey-dark);\n}\n\ncord-notification-list-launcher\n  [data-cord-button='open-notification-list']\n  .cord-icon {\n  display: none;\n}\n\ncord-notification-list-launcher {\n  background: var(--white);\n  --cord-secondary-button-content-color: var(--black);\n  --border-radius: 32px;\n  border-radius: var(--border-radius);\n  height: 40px;\n  display: flex;\n}\n\ncord-notification-list-launcher [data-cord-button='open-notification-list'] {\n  width: var(--threaded-comments-width);\n  padding: 0 16px;\n  justify-content: start;\n}\n\ncord-notification-list-launcher\n  [data-cord-button='open-notification-list']:hover {\n  border-radius: var(--border-radius);\n  background-color: var(--grey-light);\n}\n\ncord-page-presence .cord-avatar-container {\n  box-shadow: 4px 0px 0px var(--yellow-dark);\n  height: 40px;\n  width: 40px;\n}\n\ncord-notification-list-launcher .cord-button.cord-badge::after {\n  top: unset;\n  transform: unset;\n  color: var(--white);\n  border: 0;\n  right: 16px;\n}\n\n/* CSS that is only applied to threads with metadata containing 'autogenerated: true' */\n.pin-on-video-pulse {\n  animation-name: pulse, moveToVideo;\n  animation-duration: 1s, 0.33s;\n  animation-iteration-count: 1, 1;\n  animation-delay: 0.5s, 0s;\n  bottom: calc(100% - var(--pin-y-percent));\n  left: var(--pin-x-percent);\n  transform-origin: bottom left;\n  transition-timing-function: ease;\n}\n\n@keyframes pulse {\n  0% {\n    transform: scale(1);\n  }\n  50% {\n    transform: scale(var(--pin-scale-up));\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n",
    'src/images/cursor.svg':
      '<svg width="37" height="41" fill="none" xmlns="http://www.w3.org/2000/svg"><g filter="url(#a)" fill-rule="evenodd" clip-rule="evenodd"><path d="M12.11 34.223 4.606 6.21l27.662 14.37-13.496 3.616-.23.294-6.43 9.732Z" fill="#fff"/><path d="m7.6 9.724 5.255 19.608 4.34-6.546.241-.326 9.649-2.57L7.6 9.724Z" fill="#9A6AFF"/></g><defs><filter id="a" x=".605" y="4.211" width="35.662" height="36.012" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB"><feFlood flood-opacity="0" result="BackgroundImageFix"/><feColorMatrix in="SourceAlpha" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/><feOffset dy="2"/><feGaussianBlur stdDeviation="2"/><feColorMatrix values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0"/><feBlend in2="BackgroundImageFix" result="effect1_dropShadow_1617_69089"/><feBlend in="SourceGraphic" in2="effect1_dropShadow_1617_69089" result="shape"/></filter></defs></svg>',
    'src/main.tsx':
      "import * as ReactDOM from 'react-dom/client';\nimport App from './App';\nimport './css/index.css';\n\nReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(\n  <App />,\n);\n",
    'src/utils.ts':
      "import { useEffect, useState } from 'react';\n\nexport const CORD_TOKEN_LOCALSTORAGE_KEY = 'cord_token';\nconst CORD_SAMPLE_TOKEN_ENDPOINT = 'https://api.cord.com/sample-token';\n\nconst ONE_MINUTE_MS = 60 * 1000;\nconst ONE_DAY_MS = ONE_MINUTE_MS * 60 * 24;\nconst SEVEN_DAYS_MS = ONE_DAY_MS * 7;\n\nfunction canUseLocalStorage() {\n  try {\n    typeof window.localStorage;\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function useCordSampleToken_DEMO_ONLY_NOT_FOR_PRODUCTION() {\n  const [{ value: cordAuthToken, hasExpired }, setCordAuthToken] = useState<{\n    value: string | null;\n    hasExpired: boolean;\n  }>(\n    canUseLocalStorage()\n      ? () => getLocalStorageItemWithExpiry(CORD_TOKEN_LOCALSTORAGE_KEY)\n      : { value: null, hasExpired: true },\n  );\n\n  useEffect(() => {\n    if (!cordAuthToken || hasExpired) {\n      void fetchCordSampleToken().then((token) => {\n        if (token) {\n          setCordAuthToken({ value: token, hasExpired: false });\n\n          if (canUseLocalStorage()) {\n            localStorage.setItem(\n              CORD_TOKEN_LOCALSTORAGE_KEY,\n              withExpiry(\n                token,\n                // Sample token expires after 7 days\n                getTimeInXMillisecondsFromNow(SEVEN_DAYS_MS),\n              ),\n            );\n          } else {\n            console.warn(\n              `Cannot save Cord token in the localStorage. If you refresh the page, you will lose all your messages.`,\n            );\n          }\n        }\n      });\n    }\n  }, [cordAuthToken, hasExpired]);\n\n  return cordAuthToken;\n}\n\nasync function fetchCordSampleToken(): Promise<string | null> {\n  try {\n    const response = await fetch(CORD_SAMPLE_TOKEN_ENDPOINT, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ extended: 'true' }),\n    });\n\n    if (response.status !== 200) {\n      throw new Error('Failed to fetch Cord sample token');\n    }\n\n    const { client_auth_token } = await response.json();\n    return client_auth_token;\n  } catch (e) {\n    return null;\n  }\n}\n\nexport function getLocalStorageItemWithExpiry(key: string) {\n  const itemStr = localStorage.getItem(key);\n  if (!itemStr) {\n    return { value: null, hasExpired: true };\n  }\n\n  try {\n    const item = JSON.parse(itemStr);\n    const isValid = Boolean(item.expiry && item.value);\n    if (!isValid) {\n      localStorage.removeItem(key);\n      return { value: null, hasExpired: true };\n    }\n\n    const hasExpired = new Date().getTime() > item.expiry;\n    return { value: item.value, hasExpired };\n  } catch {\n    localStorage.removeItem(key);\n    return { value: null, hasExpired: true };\n  }\n}\n\nexport function withExpiry(value: string, expiry: number) {\n  const item = {\n    value: value,\n    expiry,\n  };\n\n  return JSON.stringify(item);\n}\n\nfunction getTimeInXMillisecondsFromNow(xMilliseconds: number) {\n  return new Date(new Date().getTime() + xMilliseconds).getTime();\n}\n",
    'tsconfig.json':
      '{\n  "compilerOptions": {\n    "target": "ESNext",\n    "useDefineForClassFields": true,\n    "lib": ["DOM", "DOM.Iterable", "ESNext"],\n    "allowJs": false,\n    "skipLibCheck": true,\n    "esModuleInterop": false,\n    "allowSyntheticDefaultImports": true,\n    "strict": true,\n    "forceConsistentCasingInFileNames": true,\n    "module": "ESNext",\n    "moduleResolution": "Node",\n    "resolveJsonModule": true,\n    "isolatedModules": true,\n    "noEmit": true,\n    "jsx": "react-jsx"\n  },\n  "include": ["src", "main.tsx"],\n  "references": [{ "path": "./tsconfig.node.json" }]\n}\n',
  },
};
